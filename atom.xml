<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JevonYang的博客</title>
  
  
  <link href="https://jevonyang.github.io/atom.xml" rel="self"/>
  
  <link href="https://jevonyang.github.io/"/>
  <updated>2021-10-22T01:58:28.136Z</updated>
  <id>https://jevonyang.github.io/</id>
  
  <author>
    <name>JevonYang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flink部署简单介绍</title>
    <link href="https://jevonyang.github.io/2021/01/23/Flink%E9%83%A8%E7%BD%B2%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://jevonyang.github.io/2021/01/23/Flink%E9%83%A8%E7%BD%B2%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-01-23T11:09:54.000Z</published>
    <updated>2021-10-22T01:58:28.136Z</updated>
    
    <content type="html"><![CDATA[<p>近两年Flink作为批流一体代表异军突起，成为大数据领域数据计算框架的佼佼者；同时kubernetes作为目前最为主流硬件资源调度框架，大数据也不断向其靠拢，大数据 on kubernetes也逐渐成为部署的主流或方向。以下我们来介绍一下，flink的两种简单的部署方式，standalone和native kubernetes部署</p><h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><p>目前部署方式为flink on native kubernetes的方式部署，之前是通过flink standalone方式部署，两者方式都较为简单，kubernetes的方式更为推荐。</p><h3 id="standalone"><a href="#standalone" class="headerlink" title="standalone"></a>standalone</h3><p>部署文档： <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/deployment/cluster_setup.html">https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/deployment/cluster_setup.html</a></p><p>下载地址：<a href="https://flink.apache.org/downloads.html">https://flink.apache.org/downloads.html</a></p><p>这里简述flink的部署方式，在目标主机上下载对应flink版本（目前我们使用的是1.11.1），并解压。解压后，进入flink目录，执行<code>./bin/start-cluster.sh</code><br>即可运行，在 <a href="http://localhost:8081，即可看到flink">http://localhost:8081，即可看到flink</a> ui（如下图所示），如果是想在windows，在<code>WSL</code>中同样可以运行该命令。</p><p><img src="/.io//flink-standalone-deploy.png" alt="standalone-deploy"></p><p>通过<code>SubmitNewJob</code> -&gt; <code>Add new</code> -&gt; 填写<code>Entry Class入口类</code> -&gt; <code>submit</code>，即可提交任务。</p><p>中间有两个概念，<code>Job Manager</code>、<code>TaskManager</code>:</p><ul><li><p><code>Job Manager</code>像是总指挥，如果提交后有什么编译错误，会在<code>Job Manager</code>里的log里打印出来。</p></li><li><p><code>TaskManager</code>是具体执行者，在执行过程中有什么输出结果，或者执行过程中的错误，会在<code>TaskManager</code>的log打印出来，根据相应问题就可以具体排查错误了。</p></li></ul><h2 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h2><p>kubernetes用起来真的很快乐，真正做到资源池化，资源的隔离，并且很方便的通过docker复用，很大程度上实现了<code>build once, run anywhere</code>。</p><p>Native Kubernetes 官方文档：<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/deployment/native_kubernetes.html">https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/deployment/native_kubernetes.html</a></p><h3 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h3><p>其部署也很简单，解压后，进入flink目录，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink run-application -p 8 -t kubernetes-application -c com.yang.flink.JavaStreamingJob</span><br><span class="line">        -Dkubernetes.cluster-id=your-flink-job-id</span><br><span class="line">        -Dkubernetes.jobmanager.service-account=flink </span><br><span class="line">        -Dtaskmanager.memory.process.size=4096m </span><br><span class="line">        -Dkubernetes.taskmanager.cpu=2  </span><br><span class="line">        -Dtaskmanager.numberOfTaskSlots=4 </span><br><span class="line">        -Dkubernetes.rest-service.exposed.type=NodePort </span><br><span class="line">        # 使用NodePort暴露端口，每次部署之后，其暴露端口会不同</span><br><span class="line">        -Dkubernetes.config.file=/opt/flink-1.11.1/bin/config </span><br><span class="line">        # 如果不指定kubernetes.config文件会默认去~/.kube/config中找</span><br><span class="line">        -Dkubernetes.container.image=your/docker-registry/your-flink-docker-image:your-tag </span><br><span class="line">        local:///opt/flink/usrlib/app.jar</span><br></pre></td></tr></table></figure><p>其中有一个重要参数强调一下：</p><ul><li>指定入口类<code>entry class</code>: <code>-c com.yang.flink.JavaStreamingJob</code>，如果没有，会有一个在<code>pom.xml</code>中定义的默认值</li><li>kubernetes的service-acount： <code>-Dkubernetes.jobmanager.service-account=spark</code>，在这里声明了，并且需要提前在kubernetes中创建。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding flink-role-binding-default --clusterrole=edit --serviceaccount=default:default</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里创建的是default的权限，根据自己需要创建用户</span></span><br></pre></td></tr></table></figure></li><li>kubernetes ui暴露：<code>-Dkubernetes.rest-service.exposed.type=NodePort</code>，我们是通过NodePort暴露的，每次暴露出的端口会不同，默认是lb暴露</li><li>kubernetes目标地址及秘钥： 通过<code>-Dkubernetes.config.file</code>参数指定kubernetes的地址、秘钥，如果没有，默认值为<code>~/.kube/config</code></li><li>docker镜像：<code>Dkubernetes.container.image</code>，指定需要部署的镜像，并且kubernetes可以获取到即可</li><li>指定docker镜像中jar路径：<code>local:///opt/flink/usrlib/app.jar</code>,根据dockerfile中的内容定义。</li></ul><p><img src="/.io//flink-native-kubernetes-deploy.png" alt="native-kubernetes-deploy"></p><h3 id="docker镜像打包"><a href="#docker镜像打包" class="headerlink" title="docker镜像打包"></a>docker镜像打包</h3><p>以下Dockerfile根据官网提供改写而来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM flink:1.11.1-scala_2.11-java8</span><br><span class="line">RUN mkdir -p $FLINK_HOME/usrlib</span><br><span class="line">RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo &#x27;Asia/Shanghai&#x27; &gt;/etc/timezone</span><br><span class="line">ADD target/your-jar.jar $FLINK_HOME/usrlib/app.jar</span><br></pre></td></tr></table></figure><p>说几个点：</p><ul><li>基础镜像dockerhub上有，根据需要的版本选择即可。</li><li>增加了时区的设置，避免时区错误，差八个小时的问题。</li></ul><h3 id="jenkins部署flink-on-native-kubernetes"><a href="#jenkins部署flink-on-native-kubernetes" class="headerlink" title="jenkins部署flink on native kubernetes"></a>jenkins部署flink on native kubernetes</h3><p>大家可以通过本机<code>WSL</code>，只要可以连接内网的kubernetes，通过以上命令即可部署。</p><p>为了进步方便部署，还可以部署一套jenkins和flink进行部署。</p><p>我在上面设置了job，当提交新任务的时候注意一下几点：</p><ul><li><code>-c com.yang.flink.JavaStreamingJob</code>入口类是否正确，</li><li><code>-Dkubernetes.container.image</code>中镜像的名称和tag是否正确</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">node (&#x27;master&#x27;)&#123;</span><br><span class="line">   </span><br><span class="line">    stage(&quot;Job submit&quot;)&#123;</span><br><span class="line">        sh &quot;/opt/flink-1.11.1/bin/flink run-application -p 8 -t kubernetes-application -c com.yang.flink.JavaStreamingJob&quot; +</span><br><span class="line">        &quot; -Dkubernetes.cluster-id=your-flink-job-id&quot; +</span><br><span class="line">        &quot; -Dkubernetes.jobmanager.service-account=flink&quot; +</span><br><span class="line">        &quot; -Dtaskmanager.memory.process.size=4096m&quot; +</span><br><span class="line">        &quot; -Dkubernetes.taskmanager.cpu=2&quot; + </span><br><span class="line">        &quot; -Dtaskmanager.numberOfTaskSlots=4&quot; + </span><br><span class="line">        &quot; -Dkubernetes.rest-service.exposed.type=NodePort&quot; + </span><br><span class="line">        &quot; -Dkubernetes.config.file=/opt/flink-1.11.1/bin/config&quot; + </span><br><span class="line">        &quot; -Dkubernetes.container.image=your/docker-registry/your-flink-docker-image:your-tag&quot;+</span><br><span class="line">        &quot; local:///opt/flink/usrlib/app.jar&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如果提交错误，可以直接在kubernetes中停止该任务，也可以通过kubernetes暴露出的端口，进入flink ui，<code>cancel job</code>,相应的容器会自动销毁。</p><p>Enjoy flink! Good Luck!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近两年Flink作为批流一体代表异军突起，成为大数据领域数据计算框架的佼佼者；同时kubernetes作为目前最为主流硬件资源调度框架，大数据也不断向其靠拢，大数据 on kubernetes也逐渐成为部署的主流或方向。以下我们来介绍一下，flink的两种简单的部署方式，s</summary>
      
    
    
    
    
    <category term="大数据" scheme="https://jevonyang.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>在SpringWebFlux使用缓存</title>
    <link href="https://jevonyang.github.io/2020/09/21/[Reactive]%E5%9C%A8SpringWebFlux%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98/"/>
    <id>https://jevonyang.github.io/2020/09/21/[Reactive]%E5%9C%A8SpringWebFlux%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98/</id>
    <published>2020-09-21T07:37:58.000Z</published>
    <updated>2021-10-22T01:58:28.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Project-Reactor中的Cache对象"><a href="#Project-Reactor中的Cache对象" class="headerlink" title="Project Reactor中的Cache对象"></a>Project Reactor中的Cache对象</h2><p>虽然reactor-netty使用nio的方式读写数据源大大加快了程序的响应速度，但是无论使用什么方法，远程数据读写都无法追赶上本地缓存的速度。</p><p>Project Reactor也提供了Cache的接入手段。在加入以下依赖，即可使用缓存对象:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/io.projectreactor.addons/reactor-extra --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.projectreactor.addons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;reactor-extra&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol><li><a href="https://projectreactor.io/docs/extra/release/api/reactor/cache/CacheMono.html#CacheMono--">CacheMono</a></li><li><a href="https://projectreactor.io/docs/extra/release/api/reactor/cache/CacheFlux.html#CacheFlux--">CacheFlux</a></li></ol><p>从名字上可以看出，<code>CacheMono</code>和<code>Mono</code>相对，代表[0..1]的对象，<code>CacheFlux</code>和<code>Flux</code>相对，代表[0..N]的对象。</p><p>事实上,在Spring Cloud Gateway源码中，就使用到了<code>CacheFlux</code>，用于缓存路由信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public CachingRouteDefinitionLocator(RouteDefinitionLocator delegate) &#123;</span><br><span class="line">this.delegate = delegate;</span><br><span class="line">routeDefinitions = CacheFlux.lookup(cache, &quot;routeDefs&quot;, RouteDefinition.class)</span><br><span class="line">.onCacheMissResume(this.delegate::getRouteDefinitions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CacheFlux官方文档例子"><a href="#CacheFlux官方文档例子" class="headerlink" title="CacheFlux官方文档例子"></a>CacheFlux官方文档例子</h2><p>官方一下两个例子，一个是<code>Generic cache entry points</code>，另一个是<code>Map endpoints</code></p><h3 id="Generic-cache-entry-points"><a href="#Generic-cache-entry-points" class="headerlink" title="Generic cache entry points"></a>Generic cache entry points</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference&lt;Context&gt; storeRef = new AtomicReference&lt;&gt;(Context.empty());</span><br><span class="line">   Flux&lt;Integer&gt; cachedFlux = CacheFlux</span><br><span class="line">              .lookup(k -&gt; Mono.justOrEmpty(storeRef.get().getOrEmpty(k))</span><br><span class="line">                               .cast(Integer.class)</span><br><span class="line">                               .flatMap(max -&gt; Flux.range(1, max)</span><br><span class="line">                                                   .materialize()</span><br><span class="line">                                                   .collectList()),</span><br><span class="line">                              key)</span><br><span class="line">              .onCacheMissResume(Flux.range(1, 10))</span><br><span class="line">              .andWriteWith((k, sigs) -&gt; Flux.fromIterable(sigs)</span><br><span class="line">                                             .dematerialize()</span><br><span class="line">                                             .last()</span><br><span class="line">                                             .doOnNext(max -&gt; storeRef.updateAndGet(ctx -&gt; ctx.put(k, max)))</span><br><span class="line">                                             .then());</span><br></pre></td></tr></table></figure><h3 id="Map-endpoints"><a href="#Map-endpoints" class="headerlink" title="Map endpoints"></a>Map endpoints</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String key = &quot;myCategory&quot;;</span><br><span class="line">LoadingCache&lt;String, Object&gt; graphs = Caffeine</span><br><span class="line">    .newBuilder()</span><br><span class="line">    .maximumSize(10_000)</span><br><span class="line">    .expireAfterWrite(5, TimeUnit.MINUTES)</span><br><span class="line">    .refreshAfterWrite(1, TimeUnit.MINUTES)</span><br><span class="line">    .build(key -&gt; createExpensiveGraph(key));</span><br><span class="line"></span><br><span class="line">Flux&lt;Integer&gt; cachedMyCategory = CacheFlux</span><br><span class="line">    .lookup(graphs.asMap(), key, Integer.class)</span><br><span class="line">    .onCacheMissResume(repository.findAllByCategory(key));</span><br></pre></td></tr></table></figure><p>我们以Map endpoints的例子说明。</p><p>在上面<code>Map endpoints</code>的例子上可以看到,使用了<code>Caffeine</code>缓存，这里也可以换成<code>Guava Cache</code>或者<code>ConcurrentHashMap</code>甚至<code>Hashmap</code>，使用<code>Hashmap</code>的时候，取决并发逻辑，尤其在写缓存的时候。</p><p>代码逻辑很简单，通过<code>lookUp</code>方法查找缓存，如果没有找到，通过<code>onCacheMissResume</code>方法查找数据源。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在定义了LoadingCache，我希望使用<code>refresh(key)</code>的方式更新缓存，但是发生问题。下面是我使用的<code>LoadingCache.build()</code>方法定义的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.build(new CacheLoader&lt;String, Object&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">    public YourType load(String key) throws Exception &#123;</span><br><span class="line">    return getYourTypeValue(key); // 同步代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是在刷新缓存后，再使用<code>CacheFlux</code>则会报错:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content of cache for key xxx cannot be cast to List&lt;Signal&gt;</span><br></pre></td></tr></table></figure><p>说一个不成熟的<strong>结论</strong>：</p><p><strong>不能通过<code>refresh()</code>方法来刷新缓存</strong></p><p>为什么会这样？我们接下来看一这一块的源码是如何写的。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;KEY, VALUE&gt; FluxCacheBuilderMapMiss&lt;VALUE&gt; lookup(Map&lt;KEY, ? super List&gt; cacheMap, KEY key, Class&lt;VALUE&gt; valueClass) &#123;</span><br><span class="line">return otherSupplier -&gt;</span><br><span class="line">Flux.defer(() -&gt; &#123;</span><br><span class="line">Object fromCache = cacheMap.get(key);</span><br><span class="line">            if (fromCache == null) &#123;</span><br><span class="line">return otherSupplier.get()</span><br><span class="line">.materialize()</span><br><span class="line">.collectList()</span><br><span class="line">.doOnNext(signals -&gt; cacheMap.put(key, signals))</span><br><span class="line">.flatMapIterable(Function.identity())</span><br><span class="line">.dematerialize();</span><br><span class="line">&#125; else if (fromCache instanceof List) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">List&lt;Signal&lt;VALUE&gt;&gt; fromCacheSignals = (List&lt;Signal&lt;VALUE&gt;&gt;) fromCache;</span><br><span class="line">return Flux.fromIterable(fromCacheSignals)</span><br><span class="line">                    .dematerialize();</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable cause) &#123;</span><br><span class="line">return Flux.error(new IllegalArgumentException(&quot;Content of cache for key &quot; + key + &quot; cannot be cast to List&lt;Signal&gt;&quot;, cause));</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return Flux.error(new IllegalArgumentException(&quot;Content of cache for key &quot; + key + &quot; is not a List&quot;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的逻辑比较简单，其中<code>otherSupplier</code>实际上指的是<code>onCacheMissResume</code>方法中的参数；<code>Flux.defer</code>顾名思义，延迟加载，当需要的时候才进行加载。</p><p>首先，代码从cacheMap中拿到key对应的缓存内容，接下来就是进行判断，如果没有，则通过<code>otherSupplier</code>去读取数据源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (fromCache == null) &#123;</span><br><span class="line">return otherSupplier.get()</span><br><span class="line">.materialize()</span><br><span class="line">.collectList()</span><br><span class="line">.doOnNext(signals -&gt; cacheMap.put(key, signals))</span><br><span class="line">.flatMapIterable(Function.identity())</span><br><span class="line">.dematerialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有三个细节，一个是<code>materialize</code>方法，将对应数据<strong>具象化</strong>。我们知道，在reactive中Flux和Mono各种操作符，只是对数据做操作的描述，而不是数据对象本身，我们不能将操作符做缓存。做一个比方，我们各种操作符就相当于管道，而数据通过管道做对应的操作，最后形成所需要的内容，而所需要的内容被<code>subscibe()</code>方法消费，而真正的被消费的对象（或者说数据）则是源头对象中的<code>subscription</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final Flux&lt;Signal&lt;T&gt;&gt; materialize() &#123;</span><br><span class="line">return onAssembly(new FluxMaterialize&lt;&gt;(this));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>materialize</code>我们将数据转换成<code>Signal&lt;T&gt;</code>，而这个<code>Singal</code>里则包含我们所需要消费的数据，即可作为消费的数据来源。</p><p>另外一个细节在<code>doOnNext</code>方法中,拿到<code>signals</code>对象后,将数据放回cacheMap中，所以我们<strong>无需在代码中显式的将数据插入缓存</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.doOnNext(signals -&gt; cacheMap.put(key, signals))</span><br></pre></td></tr></table></figure><p>第三个，则是<code>dematerialize()</code>，显然该方法与<code>materialize()</code>相对，是将将<code>Signal&lt;T&gt;</code>转换成<code>T</code>,进而进行下一步的操作或者消费。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final &lt;X&gt; Flux&lt;X&gt; dematerialize() &#123;</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">Flux&lt;Signal&lt;X&gt;&gt; thiz = (Flux&lt;Signal&lt;X&gt;&gt;) this;</span><br><span class="line">return onAssembly(new FluxDematerialize&lt;&gt;(thiz));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从中我们发现<code>Singal</code>是一个容器，用于存放实际数据数据。</strong></p><p>接下来，我们来看如果在cacheMap中能够拿到key对应的缓存内容。如果是拿到的缓存是List对象，则进行类型转换，将<code>Signal&lt;T&gt;</code>转换成<code>T</code>，即<code>dematerialize()</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else if (fromCache instanceof List) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">List&lt;Signal&lt;VALUE&gt;&gt; fromCacheSignals = (List&lt;Signal&lt;VALUE&gt;&gt;) fromCache;</span><br><span class="line">return Flux.fromIterable(fromCacheSignals)</span><br><span class="line">        .dematerialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里我们就知道为什么通过直接缓存刷新之后，再使用缓存会报错？在刷新的代码中，直接将缓存类型<code>T</code>放入缓存，而不是<code>Signal&lt;T&gt;</code>，当再次使用缓存时候，自然不能做类型转换<code>(List&lt;Signal&lt;VALUE&gt;&gt;) fromCache</code>，于是报出类型转换错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.build(new CacheLoader&lt;String, Object&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">    public YourType load(String key) throws Exception &#123;</span><br><span class="line">    return getYourTypeValue(key); // 同步代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. cacheMap查询 -&gt; 如果没有 -&gt; 通过 onCacheMissResume中参数的方法查询数据 </span><br><span class="line">-&gt; 通过materialize()方法将数据具象化，把T转换为Signal&lt;T&gt; </span><br><span class="line">            -&gt; 写入缓存map -&gt; 通过dematerialize()方法，反具象化，把Sinal&lt;T&gt;转T -&gt; 交给下步使用</span><br><span class="line"></span><br><span class="line">2. cacheMap查询 -&gt; 如果有 -&gt; 通过dematerialize()方法，反具象化，把Sinal&lt;T&gt;转T -&gt; 交给下步使用</span><br></pre></td></tr></table></figure><h3 id="如何改进？（课后题-D）"><a href="#如何改进？（课后题-D）" class="headerlink" title="如何改进？（课后题 :D）"></a>如何改进？（课后题 :D）</h3><p>从上面的代码分析我们可以看到，缓存中存放的是<code>Singal&lt;T&gt;</code>，所以我们需要将<code>T</code>转换成<code>Singal&lt;T&gt;</code>放入缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.build(new CacheLoader&lt;String, Object&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">    public YourType load(String key) throws Exception &#123;</span><br><span class="line">    return Signal.next(getYourTypeValue(key)); // 同步代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过<code>Signal.next(getYourTypeValue(key))</code>这样的方法，放入缓存后是否可用，待各位读者自行验证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Project-Reactor中的Cache对象&quot;&gt;&lt;a href=&quot;#Project-Reactor中的Cache对象&quot; class=&quot;headerlink&quot; title=&quot;Project Reactor中的Cache对象&quot;&gt;&lt;/a&gt;Project Reacto</summary>
      
    
    
    
    
    <category term="reactive, spring webflux" scheme="https://jevonyang.github.io/tags/reactive-spring-webflux/"/>
    
  </entry>
  
  <entry>
    <title>Java如何实现一个回调地狱（Callback Hell）？</title>
    <link href="https://jevonyang.github.io/2019/09/20/Java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%EF%BC%88Callback%20Hell%EF%BC%89%EF%BC%9F/"/>
    <id>https://jevonyang.github.io/2019/09/20/Java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%EF%BC%88Callback%20Hell%EF%BC%89%EF%BC%9F/</id>
    <published>2019-09-20T09:58:58.000Z</published>
    <updated>2021-10-22T01:58:28.136Z</updated>
    
    <content type="html"><![CDATA[<p>对于回调地狱（Callback hell），想必大家都不陌生，尤其对于前端的朋友，当然前端的朋友通过各种办法去避免回调地狱，比如Promise。但是对于后端的朋友，尤其在RxJava、Reactor等反应式编程框架兴起之后，对于回调地狱只是听得多，但是见得的少。</p><p>为了更好了解回调地狱Callback hell问题在哪，我们首先需要学会怎么写出一个回调地狱。在之前，我们得知道什么是回调函数。</p><blockquote><p>本文将包含：</p><ul><li>  <strong>什么是回调</strong></li><li>  <strong>回调的优势</strong></li><li>  <strong>回调地狱是什么</strong></li><li>  <strong>为什么会出现回调地狱</strong></li><li>  <strong>回调和Future有什么区别</strong></li><li>  <strong>如何解决回调地狱</strong></li></ul></blockquote><p>我们今天从最开始讲起，先讲讲什么是回调函数。</p><h1 id="什么是回调函数？"><a href="#什么是回调函数？" class="headerlink" title="什么是回调函数？"></a>什么是回调函数？</h1><p>在百度百科上，是这么说的：</p><blockquote><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 回调是任何一个被以方法为其第一个参数的其它方法的调用的方法。很多时候，回调是一个当某些事件发生时被调用的方法。</p></blockquote><p>什么？不好理解？确实很难理解，并且这段解释还有指针云云，对于java用户实在是不友好。</p><p>给大家举个例子，供大家参考，也欢迎批评指正：</p><blockquote><p>回调：调用方在调用被调方后，被调方还将结果反馈给调用方。（A调用B，B完成后，将结果反馈给A）</p></blockquote><blockquote><p>举个例子：老板安排员工一项工作，员工去完成。员工完成工作后，给老板反馈工作结果。这个过程就叫回调。 <img src="https://user-gold-cdn.xitu.io/2019/9/20/16d4e14b163f160d?w=537&h=296&f=png&s=10547" alt="回调示例" title="回调示例"></p></blockquote><p>这下容易理解很多了吧！Talk is cheap, Show me the code! 好，我们就用这个写一个简单的例子。</p><h2 id="回调的例子"><a href="#回调的例子" class="headerlink" title="回调的例子"></a>回调的例子</h2><h2 id="Callback接口"><a href="#Callback接口" class="headerlink" title="Callback接口"></a>Callback接口</h2><p>首先，我们先写一个如下的<code>Callback</code>接口，接口只包含一个方法，用于callback操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangzijing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Boss类"><a href="#Boss类" class="headerlink" title="Boss类"></a>Boss类</h2><p>老板是被反馈的对象，于是需要实现<code>Callback</code>这个接口，重载<code>callback</code>方法；对于老板具体要干什么，当然是做大生意，于是有了<code>makeBigDeals</code>方法；老板当然不能是光杆司令，他需要一个员工，我们再构造方法里给他添加一个员工<code>Worker</code>，稍后我们来实现Worker类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">Callback</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Worker worker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(Worker worker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.worker = worker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBigDeals</span><span class="params">(<span class="keyword">final</span> String someDetail)</span> </span>&#123;</span><br><span class="line">worker.work(someDetail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h2><p>员工类，很简单，出入一个工作，完成就好了，返回结果即可。但是如何完成回调？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">work</span><span class="params">(String someWork)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;result&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们很容易想到就是这个思路，非常符合思维的逻辑，但是在回调中，我们需要做一些改变。</p><h2 id="让代码回调起来"><a href="#让代码回调起来" class="headerlink" title="让代码回调起来"></a>让代码回调起来</h2><p>对于员工来说，需要知道两点，谁是老板，需要干啥。于是，输入两个参数，分别是老板和工作内容。具体内容分两步，首先完成任务，之后则是汇报给老板。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(Callback&lt;String&gt; boss, String someWork)</span> </span>&#123;</span><br><span class="line">String result = someWork + <span class="string">&#x27;is done!&#x27;</span>; <span class="comment">// 做一些具体的处理</span></span><br><span class="line">boss.callback(result); <span class="comment">// 反馈结果给老板</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们完成Boss类。在<code>callback</code>方法中，接收到传来的结果，并对结果进行处理，我们这里仅打印出来；在<code>makeBigDeals</code>方法中，老板分配工作，员工去完成，如果<strong>完成过程是异步</strong>，则是<code>异步调用</code>，<strong>如果是同步的</strong>，则是<code>同步回调</code>，我们这里采用异步方式。</p><p>在新建线程中，我们执行<code>worker.work(Boss.this, someDetail)</code>，其中<code>Boss.this</code>即为当前对象，在这里，我们正式完成了<strong>回调</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">Callback</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(String result)</span> </span>&#123; <span class="comment">// 参数为worker输出的结果</span></span><br><span class="line">logger.info(<span class="string">&quot;Boss got: &#123;&#125;&quot;</span>, result) <span class="comment">// 接到完成的结果，并做处理，在这里我们仅打印出来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBigDeals</span><span class="params">(<span class="keyword">final</span> String someDetail)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">&quot;分配工作&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; worker.work(Boss.<span class="keyword">this</span>, someDetail)); <span class="comment">// 异步完成任务</span></span><br><span class="line">logger.info(<span class="string">&quot;分配完成&quot;</span>);</span><br><span class="line">logger.info(<span class="string">&quot;老板下班。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调结果"><a href="#回调结果" class="headerlink" title="回调结果"></a>回调结果</h2><p>Show me the result! 好，跑一下代码试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">Boss boss = <span class="keyword">new</span> Boss(worker); <span class="comment">// 给老板指派员工</span></span><br><span class="line">boss.makeBigDeals(<span class="string">&quot;coding&quot;</span>); <span class="comment">// 老板有一个代码要写</span></span><br></pre></td></tr></table></figure><p>结果如下。在结果中可以看到，老板在分配完工作后就下班了，在下班后，另一个线程通知老板收到反馈”coding is done”。至此，我们完成了<strong>异步回调</strong>整个过程。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO  2019 九月 20 11:30:54,780 [main]  - 分配工作</span><br><span class="line"> INFO  2019 九月 20 11:30:54,784 [main]  - 分配完成</span><br><span class="line"> INFO  2019 九月 20 11:30:54,784 [main]  - 老板下班。。</span><br><span class="line"> INFO  2019 九月 20 11:30:54,787 [Thread-0]  - Boss got: coding is done!</span><br></pre></td></tr></table></figure><p>我将代码示例传至Github，供大家参考。 <a href="https://github.com/JevonYang/reactor-tutorial/tree/master/src/main/java/com/yang/tutorial/callback">callback代码示例</a></p><h2 id="回调的优势"><a href="#回调的优势" class="headerlink" title="回调的优势"></a>回调的优势</h2><ul><li>  <strong>解耦</strong>，回调将<strong>子过程</strong>从<strong>主过程</strong>中解耦。 对于相同的输入，可能对其有不同的处理方式。在回调函数，我们完成主流程（例如上面的<code>Boss</code>类），对于过程中的子流程（例如上面的<code>Worker</code>类）从主流程中分离出来。对于主流程，我们只关心子过程的输入和输出，输入在上面的例子中即为<code>Worker.work</code>中的参数，而子过程的输出则是主过程的<code>callback</code>方法的参数。</li><li>  异步回调<strong>不会阻塞</strong>主线程。上面的例子清晰可以看到，员工没有完成工作之前老板就已经下班，当工作完成后，会通过另一个线程通知老板。老板在这个过程无需等待子过程。</li></ul><h1 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h1><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><blockquote><p>我们将上述功能扩展，老板先将工作交给产品经理进行设计；设计完成后，交给程序员完成编码。流程示意如图。 <img src="https://user-gold-cdn.xitu.io/2019/9/20/16d4e14b16145572?w=777&h=441&f=png&s=22141" alt="回调地狱" title="回调地狱"></p></blockquote><h2 id="将任务交给产品经理"><a href="#将任务交给产品经理" class="headerlink" title="将任务交给产品经理"></a>将任务交给产品经理</h2><p>首先，写一个Callback，内部new一个产品经理的的<code>Worker</code>，在<code>makeBigDeal</code>方法实现主任务，将任务交给产品经理；在重载的<code>callback</code>方法中，获取产品经理的输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new Callback&lt;String&gt;() &#123;</span><br><span class="line">            private Worker productManager = new Worker();</span><br><span class="line">            @Override</span><br><span class="line">            public void callback(String s) &#123;</span><br><span class="line">                System.out.println(&quot;产品经理 output: &quot; + s); // 获取产品经理的输出</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void makeBigDeals(String bigDeal) &#123;</span><br><span class="line">                System.out.println(&quot;Boss将任务交给产品&quot;);</span><br><span class="line">                new Thread(() -&gt; &#123;</span><br><span class="line">                    this.productManager.work(this, bigDeal); // 异步调用产品经理处理过程</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.makeBigDeals(&quot;design&quot;);</span><br></pre></td></tr></table></figure><h2 id="再将产品经理输出交给开发"><a href="#再将产品经理输出交给开发" class="headerlink" title="再将产品经理输出交给开发"></a>再将产品经理输出交给开发</h2><p>在拿到产品经理的输出之后，再将输出交给开发。于是我们在再次实现一个<code>Callback</code>接口。同样的，在<code>Callback</code>中，new一个开发的<code>Worker</code>，在<code>coding</code>方法中，调用<code>Worker</code>进行开发；在重载的<code>callback</code>方法中，获取开发处理后的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void callback(String s) &#123;</span><br><span class="line">System.out.println(&quot;产品经理 output: &quot; + s); // 产品经理的输出</span><br><span class="line">String midResult = s + &quot; coding&quot;;</span><br><span class="line">System.out.println(&quot;产品经理设计完成，再将任务交给开发&quot;);</span><br><span class="line">new Callback&lt;String&gt;() &#123;</span><br><span class="line">private Worker coder = new Worker();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void callback(String s) &#123;</span><br><span class="line">System.out.println(&quot;result： &quot; + s); // 获取开发后的结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void coding(String coding) &#123;</span><br><span class="line">new Thread(() -&gt; coder.work(this, coding)).start(); // 调用开发的Worker进行开发</span><br><span class="line">&#125;</span><br><span class="line">&#125;.coding(midResult); // 将产品经理的输出交给开发</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整的实现"><a href="#完整的实现" class="headerlink" title="完整的实现"></a>完整的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Callback&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Worker productManager = <span class="keyword">new</span> Worker();</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;产品经理 output: &quot;</span> + s);</span><br><span class="line">                String midResult = s + <span class="string">&quot; coding&quot;</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;产品经理设计完成，再将任务交给开发&quot;</span>);</span><br><span class="line">                <span class="keyword">new</span> Callback&lt;String&gt;() &#123;</span><br><span class="line"><span class="keyword">private</span> Worker coder = <span class="keyword">new</span> Worker();</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;result： &quot;</span> + s);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">(String coding)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">new</span> Thread(() -&gt; coder.work(<span class="keyword">this</span>, coding)).start();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.coding(midResult);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBigDeals</span><span class="params">(String bigDeal)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Boss将任务交给产品&quot;</span>);</span><br><span class="line">                <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">this</span>.productManager.work(<span class="keyword">this</span>, bigDeal)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.makeBigDeals(<span class="string">&quot;design&quot;</span>);</span><br></pre></td></tr></table></figure><p>好了，一个简单的回调地狱完成了。Show me the result!</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Boss将任务交给产品</span><br><span class="line">产品经理 output: design is done!</span><br><span class="line">产品经理设计完成，再将任务交给开发</span><br><span class="line">result： design is done! coding is done!</span><br></pre></td></tr></table></figure><h2 id="回调地狱带来了什么？"><a href="#回调地狱带来了什么？" class="headerlink" title="回调地狱带来了什么？"></a>回调地狱带来了什么？</h2><p>到底什么是回调地狱？简单的说，回调地狱就是Callback里面又套了一个Callback，但是如果嵌套层数过多，仿佛掉入地狱，于是有了回调地狱的说法。</p><p><strong>优势：</strong> 回调地狱给我们带来什么？事实上，<strong>回调的代码如同管道一样</strong>，<strong>接收输入，并将处理后的内容输出至下一步</strong>。而回调地狱，则是多个管道连接，形成的一个流程，而各个子流程（管道）相互独立。前端的朋友可能会更熟悉一些，例如<code>Promise.then().then().then()</code>,则是多个处理管道形成的流程。</p><p><strong>劣势：</strong> 回调的方法虽然将子过程解耦，但是回调代码的可读性降低、复杂性大大增加。</p><p>Callback Hell示例：<a href="https://github.com/JevonYang/reactor-tutorial/blob/master/src/test/java/com/yang/tutorial/example/Examples.java">Callback Hell</a></p><h2 id="和Future对比"><a href="#和Future对比" class="headerlink" title="和Future对比"></a>和Future对比</h2><p>在上面，我们提到异步回调不会阻塞主线程，那么使用Future也不会阻塞，和异步回调的差别在哪？</p><p>我们写一个使用Future来异步调用的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logger.info(<span class="string">&quot;分配工作...&quot;</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; worker.work(someDetail));</span><br><span class="line">logger.info(<span class="string">&quot;分配完工作。&quot;</span>);</span><br><span class="line">logger.info(<span class="string">&quot;老板下班回家了。。。&quot;</span>);</span><br><span class="line">logger.info(<span class="string">&quot;boss got the feedback from worker: &#123;&#125;&quot;</span>, future.get());</span><br></pre></td></tr></table></figure><p>在上面的代码，我们可以看到，虽然<code>Worker</code>工作是异步的，但是老板获取工作的结果（<code>future.get()</code>）的时候却需要等待，而这个等待的过程是阻塞的。这是回调和Future一个显著的区别。</p><p>回调和Future的对比： <a href="https://github.com/JevonYang/reactor-tutorial/blob/master/src/test/java/com/yang/tutorial/example/Examples.java">callback和future对比</a></p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>如何解决回调地狱的问题，最常用的就是反应式编程<a href="https://github.com/ReactiveX/RxJava">RxJava</a>和<a href="https://github.com/reactor/reactor-core">Reactor</a>，还有Kotlin的Coroutine协程，OpenJDK搞的<a href="http://openjdk.java.net/projects/loom/">Project Loom</a>。其中各有优势，按下不表。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下：</p><ol><li> <strong>什么是回调</strong>。回调是调用方在调用被调方后，被调方还将结果反馈给调用方。（A调用B，B完成后，将结果反馈给A）</li><li> <strong>回调的优势</strong>。1）子过程和主过程解耦。2）异步调用并且不会阻塞主线程。</li><li> <strong>回调地狱是什么</strong>。回调地狱是回调函数多层嵌套，多到看不清=。=</li><li> <strong>为什么会出现回调地狱</strong>。每一个回调像一个管道，接受输出，处理后将结果输出到下一管道。各个管道处理过程独立，多个管道组成整个处理过程。</li><li> <strong>回调和Future有什么区别</strong>。1）两者机制不同；2）Future在等待结果时会阻塞，而回调不会阻塞。</li><li> <strong>如何解决回调地狱</strong>。最常见的则是反应式编程RxJava和Reactor。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于回调地狱（Callback hell），想必大家都不陌生，尤其对于前端的朋友，当然前端的朋友通过各种办法去避免回调地狱，比如Promise。但是对于后端的朋友，尤其在RxJava、Reactor等反应式编程框架兴起之后，对于回调地狱只是听得多，但是见得的少。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="callback" scheme="https://jevonyang.github.io/tags/callback/"/>
    
  </entry>
  
  <entry>
    <title>Java8遍历Map的三种方式——for/stream/forEach</title>
    <link href="https://jevonyang.github.io/2019/08/28/Java8%E9%81%8D%E5%8E%86Map%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94for-stream-forEach/"/>
    <id>https://jevonyang.github.io/2019/08/28/Java8%E9%81%8D%E5%8E%86Map%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94for-stream-forEach/</id>
    <published>2019-08-28T06:22:58.000Z</published>
    <updated>2021-10-22T01:58:28.136Z</updated>
    
    <content type="html"><![CDATA[<p>最近写在基于Spring WebFlux项目遇到一个需求，希望将请求中的cookie/headers/params等信息获取，而获取后的数据结构都是<code>MultiValueMap&lt;K, V&gt;</code>的数据结构，实质上可以看做是<code>Map&lt;K, List&lt;V&gt;&gt;</code>这种数据结构。而我需要将其转换。</p><h2 id="for循环遍历"><a href="#for循环遍历" class="headerlink" title="for循环遍历"></a>for循环遍历</h2><p>Show me the code first!以下是代码，解释一下逻辑，原来的<code>cookies</code>数据结构为<code>Map&lt;String, List&lt;HttpCookie&gt;&gt;</code>,其中<code>HttpCookie</code>为cookie键值对，由于业务需要，我们需要将其转换成<code>Map&lt;String, String&gt;</code>才更方便处理，于是乎就有了以下代码。（我这里直接用了foreach循环，也可以用fori循环，例如for(int i = 0; i&lt; xx; i++)）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MultiValueMap&lt;String, HttpCookie&gt; cookies = request.getCookies(); // 从request中获取原始的cookie</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; cookieMap = new HashMap&lt;&gt;(); // 新建一个map，将cookie转入该map中</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;String, List&lt;HttpCookie&gt;&gt; itemList : cookies.entrySet()) &#123; // 遍历原始的MultiValueMap</span><br><span class="line"></span><br><span class="line">for (HttpCookie item :itemList.getValue()) &#123; // 遍历每个item中的List&lt;HttpCookie&gt;，其中的HttpCookie是我们需要的内容</span><br><span class="line">cookieMap.put(item.getName(), item.getValue()); // 存入内容</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stream流的方式处理"><a href="#stream流的方式处理" class="headerlink" title="stream流的方式处理"></a>stream流的方式处理</h2><p>在Java8中，我们可以使用流，将Collections或者数组转化成Stream，并用链式的调用更加逻辑更加清晰。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MultiValueMap&lt;String, HttpCookie&gt; cookies = request.getCookies();</span><br><span class="line">Map&lt;String, String&gt; cookieMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">cookies.entrySet() // 获取entrySet</span><br><span class="line">.stream() // 将其转化成流</span><br><span class="line">.map(Map.Entry&lt;String, List&lt;HttpCookie&gt;&gt;::getValue) // MultiValueMap&lt;String, HttpCookie&gt; -&gt; List&lt;HttpCookie&gt;</span><br><span class="line">.flatMap(List&lt;HttpCookie&gt;::stream) // List&lt;HttpCookie&gt; -&gt; HttpCookie</span><br><span class="line">.forEach(cookie -&gt; cookieMap.put(cookie.getName(), cookie.getValue())); // 遍历，存入内容</span><br></pre></td></tr></table></figure><h2 id="Collection具有的forEach方法遍历"><a href="#Collection具有的forEach方法遍历" class="headerlink" title="Collection具有的forEach方法遍历"></a>Collection具有的forEach方法遍历</h2><h3 id="继续用Stream处理"><a href="#继续用Stream处理" class="headerlink" title="继续用Stream处理"></a>继续用Stream处理</h3><p>我们可以看到通过流的方法处理cookie的方法，接下来，我们接着用相同的方法来处理请求参数，请求参数原本的数据格式依然为<code>MultiValueMap&lt;String, String&gt;</code>，可以看做是<code>Map&lt;String, List&lt;String&gt;&gt;</code>，其中请求参数名（key）对应的值（value）可能为多行，我们需要将其处理成一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MultiValueMap&lt;String, String&gt; params = request.getQueryParams();</span><br><span class="line">Map&lt;String, String&gt; paramMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">params.entrySet()</span><br><span class="line">.stream() // 将Set转换为Stream</span><br><span class="line">.forEach(entry -&gt;</span><br><span class="line">paramMap.put(</span><br><span class="line">entry.getKey(), // 将参数名写入Key</span><br><span class="line">entry.getValue().stream().collect(Collectors.joining())) // 参数值多行合并成一行写入value</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>大家可以看到，在处理参数值（value）的时候，值为<code>List&lt;String&gt;</code>数据结构，以上代码通过<code>entry.getValue().stream().collect(Collectors.joining()))</code>将其List先转化为Stream，再用流的collection方法，将其合并。这个<code>Collectors</code>还具有将<code>toSet</code>/<code>toList</code>/<code>groupingBy</code>等功能，大家可以自行研究，这里就是使用的是<code>joining</code>合并方法。</p><h3 id="存在优化点"><a href="#存在优化点" class="headerlink" title="存在优化点"></a>存在优化点</h3><p>写完后，我发现IntelliJ IDEA给我提示，显示我的代码‘不优雅’，还可以改进。IDE会对有改进空间的代码标黄，下图即为提示内容。</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/29/16cdbecc3878cb40?w=618&h=93&f=png&s=11175" alt="collection.stream.foreach" title="collection.stream.foreach"></p><p><img src="https://user-gold-cdn.xitu.io/2019/8/29/16cdbecc389003bd?w=791&h=578&f=png&s=63858" alt="String.join" title="String.join"></p><p>图一，事实上在Java8中Collection可以直接使用foreach的方法，无需转成stream再使用foreach方法。</p><p>图二，Java8增强了String的方法，可以直接使用<code>String.join</code>合并<code>List&lt;String&gt;</code>,第一个参数为连接字符串的字符，我这里用的是空格<code>&quot; &quot;</code>，第二个参数是待连接的字符串集合。</p><h3 id="使用Collection的forEach方法遍历Map"><a href="#使用Collection的forEach方法遍历Map" class="headerlink" title="使用Collection的forEach方法遍历Map"></a>使用Collection的forEach方法遍历Map</h3><p>修改后的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params.forEach((key, value) -&gt; paramMap.put(key, String.join(&quot; &quot;, value)));</span><br></pre></td></tr></table></figure><p>这个时候我就想，为什么在处理例2（处理cookie的例子）的时候没有让我直接使用<code>Collection.forEach</code>？因为处理这个的例子相对复杂，使用了流的map/flatMap等方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此时我们可以看到流的遍历Map和Collection.forEach遍历Map的区别（事实上Collection数据结构都可以使用以上方法）：</p><ul><li>流的方法更加灵活，根据业务需要可以使用map/flatMap/filter/reduce等更复杂的操作。</li><li>collection.forEach相对简单，处理简单的逻辑，干净利落，不拖泥带水。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近写在基于Spring WebFlux项目遇到一个需求，希望将请求中的cookie/headers/params等信息获取，而获取后的数据结构都是&lt;code&gt;MultiValueMap&amp;lt;K, V&amp;gt;&lt;/code&gt;的数据结构，实质上可以看做是&lt;code&gt;Map&amp;l</summary>
      
    
    
    
    
    <category term="java" scheme="https://jevonyang.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security原理介绍、源码解析——授权过程</title>
    <link href="https://jevonyang.github.io/2019/04/17/Spring%20Security%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E3%80%81%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%8E%88%E6%9D%83%E8%BF%87%E7%A8%8B/"/>
    <id>https://jevonyang.github.io/2019/04/17/Spring%20Security%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E3%80%81%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%8E%88%E6%9D%83%E8%BF%87%E7%A8%8B/</id>
    <published>2019-04-17T07:05:58.000Z</published>
    <updated>2021-10-22T01:58:28.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h3><p>当我们成功登录，获取<code>access_token</code>，即可使用该token来访问有权限的接口。如<a href="https://my.oschina.net/yangzijing/blog/3023020" title="上文">上文</a>所讲，<code>JwtAuthenticationFilter</code>将<code>access_token</code>转化为系统可识别的<code>Authentication</code>放入安全上下文，<br>则来到最后一个过滤器<code>FilterSecurityInterceptor</code>,该过滤则是判断请求是否拥有权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterSecurityInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractSecurityInterceptor</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, </span></span></span><br><span class="line"><span class="params"><span class="function">    FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">  FilterInvocation fi = <span class="keyword">new</span> FilterInvocation(request, response, chain);</span><br><span class="line">  invoke(fi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FilterInvocation fi)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((fi.getRequest() != <span class="keyword">null</span>)</span><br><span class="line">  &amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != <span class="keyword">null</span>)</span><br><span class="line">  &amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line">    <span class="comment">// filter already applied to this request and user wants us to observe</span></span><br><span class="line"><span class="comment">// once-per-request handling, so don&#x27;t re-do security checking</span></span><br><span class="line">  fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// first time this request being called, so perform security checking</span></span><br><span class="line">  <span class="keyword">if</span> (fi.getRequest() != <span class="keyword">null</span> &amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line">      fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 请求之前的工作，也就是真正的权限认证的过程</span></span><br><span class="line">  InterceptorStatusToken token = <span class="keyword">super</span>.beforeInvocation(fi);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 请求真正的controller</span></span><br><span class="line">    fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.finallyInvocation(token);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 请求后的工作</span></span><br><span class="line">  <span class="keyword">super</span>.afterInvocation(token, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FilterSecurityInterceptor的主体方法依旧在doFilter中，而其中主要的方法为invoke()，大约分为三个步骤：</p><ol><li>beforeInvocation(fi);  验证Context中的Authentication和目标url所需权限是否匹配，匹配则通过，不通过则抛出异常。</li><li>fi.getChain().doFilter(fi.getRequest(), fi.getResponse());  在此可以看做是，真正去访问目标Controller。</li><li>afterInvocation(token, null); 获取请求后的操作。</li></ol><p>首先来看看beforeInvocation()</p><h3 id="beforeInvocation"><a href="#beforeInvocation" class="headerlink" title="beforeInvocation"></a>beforeInvocation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSecurityInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> InterceptorStatusToken <span class="title">beforeInvocation</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取目标url的权限内容，这些内容可以从configuration中获取也可以用MetadataSource中获取</span></span><br><span class="line">     Collection&lt;ConfigAttribute&gt; attributes = <span class="keyword">this</span>.obtainSecurityMetadataSource().getAttributes(object);</span><br><span class="line">     <span class="comment">// ……省略</span></span><br><span class="line">    </span><br><span class="line">   Authentication authenticated = authenticateIfRequired();</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// Attempt authorization</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// AccessDecisionManager用于验证Authentication中的权限和目标url所需权限是否匹配，如果不匹配则抛出AccessDeniedException异常</span></span><br><span class="line">      <span class="keyword">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">  publishEvent(<span class="keyword">new</span> AuthorizationFailureEvent(object, attributes, authenticated,</span><br><span class="line">  accessDeniedException));</span><br><span class="line">    <span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// Attempt to run as a different user</span></span><br><span class="line">   Authentication runAs = <span class="keyword">this</span>.runAsManager.buildRunAs(authenticated, object, attributes);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 下一步则是生成InterceptorStatusToken，用于AfterInvocation步骤。有兴趣可以自己看</span></span><br><span class="line">   <span class="keyword">if</span> (runAs == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// no further work post-invocation</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> InterceptorStatusToken(SecurityContextHolder.getContext(), <span class="keyword">false</span>, attributes, object);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">  SecurityContext origCtx = SecurityContextHolder.getContext();</span><br><span class="line">  SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext());</span><br><span class="line">  SecurityContextHolder.getContext().setAuthentication(runAs);</span><br><span class="line">  <span class="comment">// need to revert to token.Authenticated post-invocation</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> InterceptorStatusToken(origCtx, <span class="keyword">true</span>, attributes, object);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>Collection&lt;ConfigAttribute&gt; attributes = this.obtainSecurityMetadataSource().getAttributes(object);</code>获取目标url所需要的权限，<br>该类实现<code>FilterInvocationSecurityMetadataSource</code>接口的方法。而配置url权限也可以从<code>WebSecurityConfig</code>中的configuration方法配置。</li><li><code>this.accessDecisionManager.decide(authenticated, object, attributes);</code><br>判断<code>Authentication</code>中的权限目标url所需权限是否匹配，匹配则通过；不匹配则抛出<code>AccessDeniedException</code>异常。<br>该方法来自<code>AbstractAccessDecisionManager</code>的实现类，系统默认实现为<code>AffirmativeBased</code>。</li><li><code>new InterceptorStatusToken(SecurityContextHolder.getContext(), false, attributes, object);</code><br>实现<code>InterceptorStatusToken</code>并返回，包括参数中的信息，如安全上下文、目标url所需权限、原始的访问请求。</li></ol><p>之后则访问目标Controller，获取真正的请求内容。</p><h3 id="afterInvocation"><a href="#afterInvocation" class="headerlink" title="afterInvocation"></a>afterInvocation</h3><p>当我们启用了<code>@PreAuthorize()</code>、<code>@PostAuthorize()</code>注解的时候则会<code>AfterInvocationManger</code>,进而有以下验证逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSecurityInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">afterInvocation</span><span class="params">(InterceptorStatusToken token, Object returnedObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// public object</span></span><br><span class="line">    <span class="keyword">return</span> returnedObject;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  finallyInvocation(token); <span class="comment">// continue to clean in this method for passivity</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (afterInvocationManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// Attempt after invocation handling</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">  returnedObject = afterInvocationManager.decide(token.getSecurityContext()</span><br><span class="line">    .getAuthentication(), token.getSecureObject(), token</span><br><span class="line">    .getAttributes(), returnedObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">  AuthorizationFailureEvent event = <span class="keyword">new</span> AuthorizationFailureEvent(</span><br><span class="line">    token.getSecureObject(), token.getAttributes(), token</span><br><span class="line">  .getSecurityContext().getAuthentication(),</span><br><span class="line">      accessDeniedException);</span><br><span class="line">  publishEvent(event);</span><br><span class="line">  <span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> returnedObject;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码则是包含<code>AfterInvocationManager</code>具体的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalMethodSecurityConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> AfterInvocationManager <span class="title">afterInvocationManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prePostEnabled()) &#123;</span><br><span class="line">    AfterInvocationProviderManager invocationProviderManager = <span class="keyword">new</span> AfterInvocationProviderManager();</span><br><span class="line">  ExpressionBasedPostInvocationAdvice postAdvice = <span class="keyword">new</span> ExpressionBasedPostInvocationAdvice(</span><br><span class="line">      getExpressionHandler());</span><br><span class="line">  PostInvocationAdviceProvider postInvocationAdviceProvider = <span class="keyword">new</span> PostInvocationAdviceProvider(</span><br><span class="line">  postAdvice);</span><br><span class="line">  List&lt;AfterInvocationProvider&gt; afterInvocationProviders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  afterInvocationProviders.add(postInvocationAdviceProvider);</span><br><span class="line">  invocationProviderManager.setProviders(afterInvocationProviders);</span><br><span class="line">  <span class="keyword">return</span> invocationProviderManager;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我们可以做些什么？"><a href="#我们可以做些什么？" class="headerlink" title="我们可以做些什么？"></a>我们可以做些什么？</h3><ol><li><p>实现<code>FilterInvocationSecurityMetadataSource</code>，用于启动时加载url所需的权限，这样就不用在configuration或者注解中将目标url权限‘写死’。<br>可以参照本例所写的实现<code>MyFilterInvocationSecurityMetadataSource</code>。</p></li><li><p>重载<code>AbstractAccessDecisionManager</code>，根据业务需要重写，请求目标权限和Authentication中权限的验证过程.<br>举个例子，Spring Security中默认的RBAC，即，权限认证都是根据角色判断，固定角色只能访问固定接口。<br>现在我们需要ACL权限模型，用户A权限为1，用户B权限为5，用户C权限为9，接口a需要权限6，则用户C可以访问，<br>而用户A、B不能访问，就是说权限大的可以访问权限小的接口，如果需要改变权限模型则重载该类即可。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>授权过程主要有哪些？</p><ol><li>获取请求目标所需权限，从<code>FilterInvocationSecurityMetadataSource</code>接口的实现类获取。</li><li>对比安全上下文中<code>Authentication</code>中的权限是否匹配，在<code>AbstractAccessDecisionManager</code>的实现类中比较。</li></ol><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>文章涉及到代码已传到gitee上，供大家参考： <a href="https://gitee.com/yangzijing/spring-security-demo">https://gitee.com/yangzijing/spring-security-demo</a></p><p>Spring Security源码庞大且复杂，本人水平有限，文章难免有错漏、表述不清之处，请大家支出。欢迎交流，希望和大家共同进步。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;流程简述&quot;&gt;&lt;a href=&quot;#流程简述&quot; class=&quot;headerlink&quot; title=&quot;流程简述&quot;&gt;&lt;/a&gt;流程简述&lt;/h3&gt;&lt;p&gt;当我们成功登录，获取&lt;code&gt;access_token&lt;/code&gt;，即可使用该token来访问有权限的接口。如&lt;a hr</summary>
      
    
    
    
    
    <category term="spring security" scheme="https://jevonyang.github.io/tags/spring-security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security原理介绍、源码解析——认证过程</title>
    <link href="https://jevonyang.github.io/2019/03/15/Spring%20Security%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E3%80%81%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/"/>
    <id>https://jevonyang.github.io/2019/03/15/Spring%20Security%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E3%80%81%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/</id>
    <published>2019-03-15T07:13:58.000Z</published>
    <updated>2021-10-22T01:58:28.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h1><p>在前后端分离的架构中，权限认证主要包含两个主要的过程：</p><ol><li>通过用户名密码换取一个令牌（Token），令牌具有不可修改性，以保证权限的安全。</li><li>用户在之后一段时间访问则不用再输入用户名密码，通过Token则可以访问被权限管理限制的接口。</li></ol><p>再进一步说，</p><ol><li>流程1，是通过用户名密码，从数据库中拿到用户的信息、权限等，并转换成安全框架（这里就是Spring Security）中可识别的身份信息（即Authentication），即视为登录成功，之后将必要的些信息转化为之后一段时间访问的凭证——Token。</li><li>流程2，则是将Token解析出来，转成安全框架中可识别身份信息，通过可识别的身份信息，框架再去判断该权限是否可以访问该端点。</li></ol><p>可以看到在流程1&amp;2中，前半部分是相同的，都是将凭证（前者为用户名密码，后者为token）转为框架可识别的身份信息，这一步我们视为<code>认证</code>流程。后半部分则为，各自认证成功的操作逻辑。流程1生成token较为简单，流程2的后半部分则是安全框架（Spring Security）中权限管理的决策逻辑，即决定是否可以访问的逻辑，这一步我们视为<code>授权</code>流程。</p><p>下面将从<code>认证</code>和<code>授权</code>两部分来讲。</p><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><h2 id="SecurityFilterChain-过滤器链"><a href="#SecurityFilterChain-过滤器链" class="headerlink" title="SecurityFilterChain 过滤器链"></a>SecurityFilterChain 过滤器链</h2><p>Spring Security采用的是filterChain的设计方式，主要的功能大都由过滤器实现，在启动项目的时候，可以在日志中看到已有的过滤器，可在类似下面的日志里找到<code>DefaultSecurityFilterChain</code>，这里面则是SecurityFilterChain</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-03-14 16:43:02.369  INFO 27251 --- [  restartedMain] o.s.s.web.DefaultSecurityFilterChain     : Creating filter chain: org.springframework.security.web.util.matcher.AnyRequestMatcher@1, [org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@1d88a93d, org.springframework.security.web.context.SecurityContextPersistenceFilter@184d52d7, org.springframework.security.web.header.HeaderWriterFilter@29d86b1e, org.springframework.security.web.authentication.logout.LogoutFilter@2ce28138, org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@320a4f73, com.yang.security.config.JwtAuthorizationTokenFilter@37e7a410, org.springframework.security.web.savedrequest.RequestCacheAwareFilter@534e475b, org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@39137df7, org.springframework.security.web.authentication.AnonymousAuthenticationFilter@7c42403f, org.springframework.security.web.session.SessionManagementFilter@1fa2ad2b, org.springframework.security.web.access.ExceptionTranslationFilter@65869e97, org.springframework.security.web.access.intercept.FilterSecurityInterceptor@163d3c44]</span><br></pre></td></tr></table></figure><p>把各个过滤器抽取出来，我们可以看到是这样，这也是过滤器链的先后顺序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. WebAsyncManagerIntegrationFilter</span><br><span class="line">2. SecurityContextPersistenceFilter</span><br><span class="line">3. HeaderWriterFilter</span><br><span class="line">4. LogoutFilter</span><br><span class="line">5. **UsernamePasswordAuthenticationFilter**</span><br><span class="line">6. **JwtAuthorizationTokenFilter**</span><br><span class="line">7. RequestCacheAwareFilter</span><br><span class="line">8. SecurityContextHolderAwareRequestFilter</span><br><span class="line">9. SessionManagementFilter</span><br><span class="line">10. ExceptionTranslationFilter</span><br><span class="line">11. FilterSecurityInterceptor</span><br></pre></td></tr></table></figure><p>这里主要讲一下<code>UsernamePasswordAuthenticationFilter</code>及相关的代码，顺带的说一下，我们自己实现<code>JwtAuthenticationFilter</code>及周边。</p><h2 id="示例：-官方的Filter——UsernamePasswordAuthenticationFilter过程"><a href="#示例：-官方的Filter——UsernamePasswordAuthenticationFilter过程" class="headerlink" title="示例： 官方的Filter——UsernamePasswordAuthenticationFilter过程"></a>示例： 官方的Filter——UsernamePasswordAuthenticationFilter过程</h2><h3 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a>UsernamePasswordAuthenticationFilter</h3><p><code>UsernamePasswordAuthenticationFilter</code>，顾名思义，是用来处理用户名密码登录的过滤器。所有的Filter核心方法都是<code>doFilter</code>，该过滤器的doFilter在其父抽象类中，过滤器只需实现<code>attemptAuthentication</code>方法即可。</p><p>源码摘录如下（并不是完整的源码，拣选重要部分阐述逻辑）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">String username = obtainUsername(request);</span><br><span class="line">String password = obtainPassword(request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据用户名密码构造AuthenticationToken</span></span><br><span class="line">UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">username, password); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将AuthenticationToken放入AuthenticationProvider进行认证</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h3><p><code>AuthenticationManager</code>中维护着一个<code>List&lt;AuthenticationProvider&gt;</code>；首先通过<code>AuthenticationProvider</code>的<code>supports</code>方法检测是否支持该类型的<code>AuthenticationToken</code>；如果支持，则使用<code>authenticate</code>认证，认证通过则将<code>AuthenticationToken</code>转换成经认证的<code>Authentication</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderManager</span> <span class="keyword">implements</span> <span class="title">AuthenticationManager</span>, <span class="title">MessageSourceAware</span>,</span></span><br><span class="line"><span class="class"><span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;AuthenticationProvider&gt; providers = Collections.emptyList();</span><br><span class="line"><span class="keyword">private</span> AuthenticationManager parent;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> eraseCredentialsAfterAuthentication = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历Providers</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">    <span class="comment">// 如果Authentication不符合，跳过后边步骤，继续循环</span></span><br><span class="line"><span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果Authentication符合，则使用该Provider进行authenticate操作</span></span><br><span class="line">result = provider.authenticate(authentication);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                copyDetails(authentication, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">&amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DaoAuthenticationProvider"><a href="#DaoAuthenticationProvider" class="headerlink" title="DaoAuthenticationProvider"></a>DaoAuthenticationProvider</h3><p>接下来，说如何将<code>AuthenticationToken</code>认证。下面是<code>DaoAuthenticationProvider</code>的父抽象类，父类中核心方法就是<code>authenticate</code>方法，而子类则只用实现<code>retrieveUser</code>方法，该方法调用<code>UserDetailsService</code>的<code>loadUserByUsername</code>。对于我们用户而言，所要做的就是实现<code>UserDetailsService</code>，重写其中的方法，通过<code>loadUserByUsername</code>从数据库中拿到用户名和密码，至于后面的验证，事实上都是由<code>AbstractUserDetailsAuthenticationProvider</code>已经做好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUserDetailsAuthenticationProvider</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">AuthenticationProvider</span>, <span class="title">InitializingBean</span>, <span class="title">MessageSourceAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">  </span><br><span class="line">String username = (authentication.getPrincipal() == <span class="keyword">null</span>) ? <span class="string">&quot;NONE_PROVIDED&quot;</span>: authentication.getName();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// DaoAuthenticationProvider中重载retrieveUser方法，而该方法中的核心方法就是UserDetailsService的loadUserByUsername</span></span><br><span class="line">user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line"></span><br><span class="line"><span class="comment">// preCheck</span></span><br><span class="line">preAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line">additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line"></span><br><span class="line"><span class="comment">// postCheck</span></span><br><span class="line">postAuthenticationChecks.check(user);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 检查成功没有问题，则创建Authentication示例</span></span><br><span class="line"><span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (UsernamePasswordAuthenticationToken.class</span><br><span class="line">.isAssignableFrom(authentication));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><ol><li><code>UsernamePasswordAuthenticationFilter.doFilter</code>获取用户名密码,生成<code>UsernamePasswordAuthenticationToken</code>；</li><li>将<code>UsernamePasswordAuthenticationToken</code>交给<code>DaoAuthenticationProvider</code>验证；</li><li><code>DaoAuthenticationProvider</code>通过<code>UserDetailsService.loadUserByUsername</code>中获取用户名、密码、权限以及其他信息，并进行比对；比对成功，则生成<code>Authentication</code>；</li><li><code>UsernamePasswordAuthenticationFilter</code>将<code>Authentication</code>放入<code>SecurityContextHolder</code>，认证成功；</li></ol><p>齐活！</p><h2 id="实践：编写自己的Filter——JwtAuthenticationFilter"><a href="#实践：编写自己的Filter——JwtAuthenticationFilter" class="headerlink" title="实践：编写自己的Filter——JwtAuthenticationFilter"></a>实践：编写自己的Filter——JwtAuthenticationFilter</h2><p>流程2的主要功能，解析Token，转换成Spring Security内部可识别的身份信息Authentication，并放入上下文中，这一步则是通过JwtAuthenticationFilter来完成，其原理与UsernamePasswordAuthenticationFilter并无二致，我们简单来看一下，当做一个小小的实践练习。</p><h3 id="JwtAuthorizationTokenFilter"><a href="#JwtAuthorizationTokenFilter" class="headerlink" title="JwtAuthorizationTokenFilter"></a>JwtAuthorizationTokenFilter</h3><p>首先编写<code>JwtAuthorizationTokenFilter</code>。我们直接扩展了<code>AbstractAuthenticationProcessingFilter</code>这个抽象类,因为想使用其<code>requiresAuthentication</code>方法判断访问端点是否需要经过该过滤器；于此同时我们需要实现一个<code>RequestMatch</code>匹配访问信息，具体实现按下不表，可以参考代码中<code>SkipUrlMatcher</code>实现自己的业务逻辑。</p><p>接下来，我们将获取的<code>access_token</code>解析，转化成<code>UserDetails</code>，代码中Step1中的User即为其具体实现。我们知道，jwt事实上是加密的，只有通过我们自己的秘钥解析才能验证成功，获取内部信息。事实上在这一步骤，我们已经验证了信息的真实性、可用性（Step1），就直接生成<code>JwtAuthenticationToken</code>（Step2），这里的authentication已经经过验证，放入<code>AuthenticationManager.authenticate</code>过程得到框架可识别的认证信息<code>Authentication</code>。将已认证身份信息放入上下文，认证过程完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthorizationTokenFilter</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JwtAuthorizationTokenFilter</span><span class="params">(RequestMatcher matcher)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(matcher);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">    HttpServletResponse httpServletResponse = (HttpServletResponse) response;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step0. 首先判断访问的端点是否需要经过该过滤器</span></span><br><span class="line">    <span class="keyword">if</span> (!requiresAuthentication(httpServletRequest, httpServletResponse)) &#123;</span><br><span class="line">      filterChain.doFilter(httpServletRequest, httpServletResponse);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String token = httpServletRequest.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step1. 将token转换成UserDetails(这里的User是自己写的UserDetail的实现)</span></span><br><span class="line">    User user = JwtUtil.accessToken2User(token.substring(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step2. 将UserDetails转换成Authentication，这里的JwtAuthenticationToken即为Authentication的实现，</span></span><br><span class="line">    <span class="comment">// 一般而言，将UserDetails放入Authentication的principle中,之后如果需要可通过Authentication.getPrinciple的方法把UserDetails取出来</span></span><br><span class="line">    JwtAuthenticationToken authenticationToken = <span class="keyword">new</span> JwtAuthenticationToken(user, token, user.getAuthorities());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step3. 这一步将AuthenticationToken交由AuthenticationProvider处理，转换成Authentication</span></span><br><span class="line">    <span class="keyword">final</span> Authentication authentication = getAuthenticationManager().authenticate(authenticationToken);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step4. 将得到的Authentication实例放入Holder，则认证完成</span></span><br><span class="line">    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step5. 进入之后的过滤器处理</span></span><br><span class="line">    filterChain.doFilter(httpServletRequest, httpServletResponse);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JwtAuthenticationProvider"><a href="#JwtAuthenticationProvider" class="headerlink" title="JwtAuthenticationProvider"></a>JwtAuthenticationProvider</h3><p>再来看一下自定义的<code>JwtAuthenticationProvider</code>。通过前面的一小节我们知道，<code>AuthenticationManager.authenticate</code>过程实际上是通过具体的<code>AuthenticationProvider</code>完成，我们前面得到了一个<code>JwtAuthenticationToken</code>，我们就专门实现一个处理该实例的<code>AuthenticationProvider</code>。在该实现方法里，<code>authenticate</code>过程我直接将传入的<code>authentication</code>（实例为<code>jwtAuthenticationToken</code>）直接返回，是因为Jwt解析过程需要对JWT进行解密、验证，所以我们传入的<code>JwtAuthenticationToken</code>已经是验证过的，故在这里没做过多的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> authentication;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (JwtAuthenticationToken.class.isAssignableFrom(authentication));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结一下我们干了什么"><a href="#总结一下我们干了什么" class="headerlink" title="总结一下我们干了什么"></a>总结一下我们干了什么</h3><ol><li>实现一个自定义<code>AuthorizationTokenFilter</code>，实现<code>doFilter</code>方法，该方法则是认证的整个过程。</li><li>获取请求信息（这一节获取的信息是JWT，上一节获取的是用户名密码），将这些信息生成一个<code>AuthenticationToken</code>（这一节生成的JwtAuthenticationToken，上一节是UsernamePasswordToken）</li><li>将<code>AuthenticationToken</code>交给<code>AuthenticationProvider</code>验证，在<code>supports</code>方法中验证是否支持该类型的<code>AuthenticationToken</code>，在<code>authenticate</code>方法中完成验证的过程。</li><li>将认证后的<code>Authentication</code>实例放入安全上下文<code>SecurityContextHolder</code>，认证过程全部完成。</li></ol><p>文章涉及到代码已传到gitee上，供大家参考： <a href="https://gitee.com/yangzijing/spring-security-demo">https://gitee.com/yangzijing/spring-security-demo</a></p><p>Spring Security源码庞大且复杂，本人水平有限，文章难免有错漏、表述不清之处，请大家支出。欢迎交流，希望和大家共同进步。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;核心原理&quot;&gt;&lt;a href=&quot;#核心原理&quot; class=&quot;headerlink&quot; title=&quot;核心原理&quot;&gt;&lt;/a&gt;核心原理&lt;/h1&gt;&lt;p&gt;在前后端分离的架构中，权限认证主要包含两个主要的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过用户名密码换取一个令牌（Token），</summary>
      
    
    
    
    
    <category term="spring security" scheme="https://jevonyang.github.io/tags/spring-security/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud实践分享-日志收集Kafka-ELK</title>
    <link href="https://jevonyang.github.io/2018/06/11/SpringCloud%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB-%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86Kafka-ELK/"/>
    <id>https://jevonyang.github.io/2018/06/11/SpringCloud%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB-%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86Kafka-ELK/</id>
    <published>2018-06-11T01:53:58.000Z</published>
    <updated>2021-10-22T01:58:28.136Z</updated>
    
    <content type="html"><![CDATA[<p>微服务应用在容器化后，日志的查询就会变成困难的问题，虽说有<a href="https://portainer.io/">portainer</a>这类的容器管理工具，能够方便的查询每个容器中的日志，但容器到达一定数量后，尤其是应用有多个实例时候，查询就成了头疼的问题。所以我们采用了Kafka-Logstash-Elasticsearch-Kibana的方案来处理日志。</p><p>首先说说我的日志收集思路：</p><ol><li>应用将日志传入kafka集群。在集群建立相应topic，并传入日志。</li><li>logstash在kafka上消费（读取）日志内容，写入elasticsearch。</li><li>kibana读elasticsearch，做对应的展示。</li></ol><p>这样的好处，1）几乎不用做特别大的修改，只需做一定的配置工作即可完成日志收集；2）日志内容输入kafka几乎没有什么瓶颈，另外kafka的扩展性能很好，也很简单；3）收集的日志几乎是实时的；4）整体的扩展性很好，很容易消除瓶颈，例如elasticsearch分片、扩展都很容易。</p><h2 id="应用侧配置"><a href="#应用侧配置" class="headerlink" title="应用侧配置"></a>应用侧配置</h2><p>在应用中，我们只需配置log4j的相应配置，将其日志输出到kafka即可。以下为配置示例，配置中包含将日志输入出命令行和kafka部分中。注意，在输出到kafka中，需要有一个appender类<code>kafka.producer.KafkaLog4jAppender</code>一般是没有的，则我在本地自己写上该类（<code>KafkaLog4jAppender.java</code>），并加入相应的文件路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=INFO,console,kafka</span><br><span class="line"></span><br><span class="line"># 输出到kafka</span><br><span class="line">log4j.appender.kafka=com.yang.config.KafkaLog4jAppender</span><br><span class="line">  #kafka.producer.KafkaLog4jAppender</span><br><span class="line">log4j.appender.kafka.topic=api-admin</span><br><span class="line">log4j.appender.kafka.brokerList=192.0.0.2:9092,192.0.0.3:9092,192.0.0.4:9092 # 这里填写kafka的ip</span><br><span class="line">log4j.appender.kafka.compressionType=none</span><br><span class="line">log4j.appender.kafka.syncSend=true</span><br><span class="line">log4j.appender.kafka.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.kafka.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L %% - %m%n</span><br><span class="line"></span><br><span class="line"># 输出到Console</span><br><span class="line"></span><br><span class="line">log4j.appender.console=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.target=System.err</span><br><span class="line">log4j.appender.console.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=%d (%t) [%p - %l] %m%n</span><br></pre></td></tr></table></figure><h2 id="KafkaLog4jAppender-java"><a href="#KafkaLog4jAppender-java" class="headerlink" title="KafkaLog4jAppender.java"></a>KafkaLog4jAppender.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaLog4jAppender</span> <span class="keyword">extends</span> <span class="title">AppenderSkeleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOTSTRAP_SERVERS_CONFIG = ProducerConfig.BOOTSTRAP_SERVERS_CONFIG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMPRESSION_TYPE_CONFIG = ProducerConfig.COMPRESSION_TYPE_CONFIG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACKS_CONFIG = ProducerConfig.ACKS_CONFIG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RETRIES_CONFIG = ProducerConfig.RETRIES_CONFIG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SERIALIZER_CLASS_CONFIG = ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VALUE_SERIALIZER_CLASS_CONFIG = ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECURITY_PROTOCOL = CommonClientConfigs.SECURITY_PROTOCOL_CONFIG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SSL_TRUSTSTORE_LOCATION = SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SSL_TRUSTSTORE_PASSWORD = SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SSL_KEYSTORE_TYPE = SslConfigs.SSL_KEYSTORE_TYPE_CONFIG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SSL_KEYSTORE_LOCATION = SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SSL_KEYSTORE_PASSWORD = SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brokerList = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String topic = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String compressionType = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String securityProtocol = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String sslTruststoreLocation = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String sslTruststorePassword = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String sslKeystoreType = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String sslKeystoreLocation = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String sslKeystorePassword = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> retries = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> requiredNumAcks = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> syncSend = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Producer&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; producer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Producer&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; getProducer() &#123;</span><br><span class="line">        <span class="keyword">return</span> producer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrokerList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brokerList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrokerList</span><span class="params">(String brokerList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerList = brokerList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRequiredNumAcks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requiredNumAcks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequiredNumAcks</span><span class="params">(<span class="keyword">int</span> requiredNumAcks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requiredNumAcks = requiredNumAcks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRetries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> retries;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRetries</span><span class="params">(<span class="keyword">int</span> retries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.retries = retries;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCompressionType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compressionType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompressionType</span><span class="params">(String compressionType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.compressionType = compressionType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTopic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> topic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTopic</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.topic = topic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getSyncSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> syncSend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSyncSend</span><span class="params">(<span class="keyword">boolean</span> syncSend)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.syncSend = syncSend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSslTruststorePassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sslTruststorePassword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSslTruststoreLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sslTruststoreLocation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSecurityProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> securityProtocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecurityProtocol</span><span class="params">(String securityProtocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.securityProtocol = securityProtocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSslTruststoreLocation</span><span class="params">(String sslTruststoreLocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sslTruststoreLocation = sslTruststoreLocation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSslTruststorePassword</span><span class="params">(String sslTruststorePassword)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sslTruststorePassword = sslTruststorePassword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSslKeystorePassword</span><span class="params">(String sslKeystorePassword)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sslKeystorePassword = sslKeystorePassword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSslKeystoreType</span><span class="params">(String sslKeystoreType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sslKeystoreType = sslKeystoreType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSslKeystoreLocation</span><span class="params">(String sslKeystoreLocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sslKeystoreLocation = sslKeystoreLocation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSslKeystoreLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sslKeystoreLocation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSslKeystoreType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sslKeystoreType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSslKeystorePassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sslKeystorePassword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activateOptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// check for config parameter validity</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">if</span> (brokerList != <span class="keyword">null</span>)</span><br><span class="line">            props.put(BOOTSTRAP_SERVERS_CONFIG, brokerList);</span><br><span class="line">        <span class="keyword">if</span> (props.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConfigException(<span class="string">&quot;The bootstrap servers property should be specified&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (topic == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConfigException(<span class="string">&quot;Topic must be specified by the Kafka log4j appender&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compressionType != <span class="keyword">null</span>)</span><br><span class="line">            props.put(COMPRESSION_TYPE_CONFIG, compressionType);</span><br><span class="line">        <span class="keyword">if</span> (requiredNumAcks != Integer.MAX_VALUE)</span><br><span class="line">            props.put(ACKS_CONFIG, Integer.toString(requiredNumAcks));</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; <span class="number">0</span>)</span><br><span class="line">            props.put(RETRIES_CONFIG, retries);</span><br><span class="line">        <span class="keyword">if</span> (securityProtocol != <span class="keyword">null</span> &amp;&amp; sslTruststoreLocation != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                sslTruststorePassword != <span class="keyword">null</span>) &#123;</span><br><span class="line">            props.put(SECURITY_PROTOCOL, securityProtocol);</span><br><span class="line">            props.put(SSL_TRUSTSTORE_LOCATION, sslTruststoreLocation);</span><br><span class="line">            props.put(SSL_TRUSTSTORE_PASSWORD, sslTruststorePassword);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sslKeystoreType != <span class="keyword">null</span> &amp;&amp; sslKeystoreLocation != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    sslKeystorePassword != <span class="keyword">null</span>) &#123;</span><br><span class="line">                props.put(SSL_KEYSTORE_TYPE, sslKeystoreType);</span><br><span class="line">                props.put(SSL_KEYSTORE_LOCATION, sslKeystoreLocation);</span><br><span class="line">                props.put(SSL_KEYSTORE_PASSWORD, sslKeystorePassword);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        props.put(KEY_SERIALIZER_CLASS_CONFIG, <span class="string">&quot;org.apache.kafka.common.serialization.ByteArraySerializer&quot;</span>);</span><br><span class="line">        props.put(VALUE_SERIALIZER_CLASS_CONFIG, <span class="string">&quot;org.apache.kafka.common.serialization.ByteArraySerializer&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.producer = getKafkaProducer(props);</span><br><span class="line">        LogLog.debug(<span class="string">&quot;Kafka producer connected to &quot;</span> + brokerList);</span><br><span class="line">        LogLog.debug(<span class="string">&quot;Logging for topic: &quot;</span> + topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Producer&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; getKafkaProducer(Properties props) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KafkaProducer&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(LoggingEvent event)</span> </span>&#123;</span><br><span class="line">        String message = subAppend(event);</span><br><span class="line">        LogLog.debug(<span class="string">&quot;[&quot;</span> + <span class="keyword">new</span> Date(event.getTimeStamp()) + <span class="string">&quot;]&quot;</span> + message);</span><br><span class="line">        Future&lt;RecordMetadata&gt; response = producer.send(<span class="keyword">new</span> ProducerRecord&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;(topic, message.getBytes()));</span><br><span class="line">        <span class="keyword">if</span> (syncSend) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">subAppend</span><span class="params">(LoggingEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.layout == <span class="keyword">null</span>) ? event.getRenderedMessage() : <span class="keyword">this</span>.layout.format(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">            <span class="keyword">this</span>.closed = <span class="keyword">true</span>;</span><br><span class="line">            producer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requiresLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="logstash配置"><a href="#logstash配置" class="headerlink" title="logstash配置"></a>logstash配置</h2><p>logstash可能会有快速启动实例的需求，我们就采用docker部署，能够快速启动、扩展等功能。</p><p>镜像就直接logstash官方镜像<a href="https://hub.docker.com/_/logstash/">logstash docker镜像</a>，我们选择了一种最简单启动方式做演示，具体还有多种docker部署方法，可以参考以上链接。</p><p>docker启动命令，input输入中，指定kafka集群地址和对应topic；输出，则是elasticsearch集群地址、索引，以及elastisearch配置参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#启动命令</span><br><span class="line">docker run -it -d logstash -e &#x27;input &#123; kafka &#123; </span><br><span class="line">bootstrap_servers =&gt; &quot;kafkaIp1:9092,kafkaIp2:9092&quot; </span><br><span class="line">topics =&gt; [&quot;api-admin&quot;] &#125; &#125; </span><br><span class="line">output &#123; elasticsearch &#123; </span><br><span class="line">hosts =&gt; [&quot;elasticsearch1:9200&quot;,&quot;elasticsearch2:9200&quot;,&quot;elasticsearch3:9200&quot;] </span><br><span class="line">index =&gt; &quot;api-admin-%&#123;+YYYY.MM.dd&#125;&quot; </span><br><span class="line">flush_size =&gt; 20000 </span><br><span class="line">idle_flush_time =&gt; 10 </span><br><span class="line">template_overwrite =&gt; true </span><br><span class="line">&#125; &#125;&#x27;</span><br></pre></td></tr></table></figure><p>在marathon中启动在Command选项中加入参数<code>logstash -e &#39;input &#123;&#125; output &#123;&#125;&#39;</code>即可。另外说一句， 如果在容器编排系统（mesos/marathon、kubernetes）中，可能会有健康检查要求，其端口为9600。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;微服务应用在容器化后，日志的查询就会变成困难的问题，虽说有&lt;a href=&quot;https://portainer.io/&quot;&gt;portainer&lt;/a&gt;这类的容器管理工具，能够方便的查询每个容器中的日志，但容器到达一定数量后，尤其是应用有多个实例时候，查询就成了头疼的问题。所以</summary>
      
    
    
    
    
    <category term="spring cloud" scheme="https://jevonyang.github.io/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud实践分享-Config配置中心</title>
    <link href="https://jevonyang.github.io/2018/06/07/SpringCloud%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB-Config%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <id>https://jevonyang.github.io/2018/06/07/SpringCloud%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB-Config%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</id>
    <published>2018-06-07T06:17:58.000Z</published>
    <updated>2021-10-22T01:58:28.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在服务中经常会遇到一些易变的参数，例如数据库地址、超时时间等等。这些参数与代码关系耦合度低，但是每改一次就去修改代码中的参数，再去编译部署<br>显得很蠢，于是就有了配置中心得个实现。目前用的比较多的配置中心有SpringCloudConfig和携程的<a href="https://github.com/ctripcorp/apollo">Apollo</a>。<br>SpringCloudConfig的好处是和SpringCloud绑定，全家桶（有好处有坏处，你懂的），部署简单；而Apollo部署比较麻烦，它首先要把部署地址写死在apollo-client中编译出来，<br>然后在配置项目中引用apollo-client……（既然是配置中心，为什么配置中心本身不能做到代码和参数的解耦？！）当然，这都是我一些私货，<br>事实上apollo功能十分强大，权限功能完整，并且支持多语言，大家都知道携程的技术栈主要是.net。两种各有长短，有兴趣的同学可以去github上看看，<br>文档说明十分详细。书归正传，接下来主要讲Spring Cloud Config。</p><h3 id="启动Config"><a href="#启动Config" class="headerlink" title="启动Config"></a>启动Config</h3><p>Config的配置同样简单:加入依赖<code>spring-cloud-config-server</code>，入口类加入注解<code>@EnableConfigServer</code>和<code>@EnableDiscoveryClient</code>，<br>前一个注解是使能Config注册中心，后一个则是注册到Eureka上，让其他服务找到该服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableConfigServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ConfigApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Config-Server配置"><a href="#Config-Server配置" class="headerlink" title="Config Server配置"></a>Config Server配置</h3><p>首先说注册中心Eureka相关内容，服务注册地址<code>eureka.client.serviceUrl.defaultZone</code>以及自己是谁<code>spring.application.name</code>即可。<br>我在这里加上<code>prefer-ip-address</code>的配置，后面会相信说明。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>然后是就是配置中心相关内容。配置中心一般采用git或svn才作为配置存储端，官方文档上还有以jdbc数据库来存储的，本文以git来说明。<br>其中<code>spring.cloud.config.server.uri</code>是配置文件存放的git地址，为了更直观演示，我在gitee上配置相应的内容。<br>而<code>search-paths</code>则是在该库下的搜索路径，我们这里配置成了<code>&#39;&#123;application&#125;&#39;</code>代表不同服务会去git项目下找与项目名（<code>spring.application.name</code>）对应的文件。<br>其规则为<code>&#123;application&#125;-&#123;profile&#125;.yml</code></p><p>例如，服务A中<code>spring.application.name: fuwu1</code>,则服务A在启动的时，配置中心则会找<code>git.uri</code>下的<code>fuwu1.yml</code>文件交给服务A作为配置。<br>服务A启动时，带有<code>-Dspring.profiles.active=master</code>参数时,则会配置中心则会找<code>git.uri</code>下的<code>fuwu1-master.yml</code>文件交给服务A作为配置。</p><p>配置同样需要有权限管理，而配置中心的权限逻辑和git相同（如果你使用git作为存储后端）。<br>我们可以配置<code>username</code>和<code>password</code>，如果需要有更高的要求，还可以和git一样，配置公钥私钥。在git上放上公钥，<br>在<code>private-key</code>这里直接填写私钥内容，你甚至可以代码上去掉权限信息，而在部署的服务器中配上私钥。总之，git是怎么配它就是怎么配置。<br>（<a href="https://my.oschina.net/yangzijing/blog/1476531">git相关内容点击这里</a>）</p><p>还有一种配置路径的逻辑大概是这样：<code>uri: git@your-git-address:your-config-repo/&#123;application&#125;.git</code>，不同的项目配置放在不同的仓库，<br>这样可以配置不同仓库的权限。如果是这样配置，仓库里的文件命规则是<code>application-&#123;profile&#125;.yml</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">git@gitee.com:yangzijing/config.git</span></span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">&#x27;&#123;application&#125;&#x27;</span></span><br><span class="line">          <span class="comment">#uri: git@your-git-address:your-config-repo/&#123;application&#125;.git</span></span><br><span class="line">          <span class="comment">#private-key:</span></span><br><span class="line">          <span class="comment">#username: yourusername</span></span><br><span class="line">          <span class="comment">#password: yourpassword</span></span><br></pre></td></tr></table></figure><h3 id="Config客户端配置"><a href="#Config客户端配置" class="headerlink" title="Config客户端配置"></a>Config客户端配置</h3><p>客户端配置同样也是两类，eureka的配置和config的配置，要注意这些配置要写在bootstrap.yml中。简单来讲bootstrap和application的区别，<br>bootstrap.yml中的配置先启动，application.yml中的配置后启动，而需要动态配置的配置项则写在application.yml中。</p><p>Eureka相关的配置不再赘述，主要关心一下config的配置。配置可以有两种，1）指定config的ip，直接在<code>spring.cloud.config.uri</code>配上地址即可。<br>2）通过Eureka找到Config的地址,配置<code>spring.cloud.config.discovery.enabled=true</code>和<code>discovery.service-id</code>(这里的service-id和config项目的<code>spring.application.name</code>名字一致，其默认值是configserver)。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-admin</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment">#uri: http://ip:port</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">service-id:</span> <span class="string">config-server</span></span><br></pre></td></tr></table></figure><p>在api-admin项目中，增加了一个<code>from</code>配置，在<code>application.yml</code>可写可不写，如果写，还可以添加默认值<code>from: $&#123;from:hello&#125;</code>;如果不写，也可以，<br>同样也可以在java文件中直接引用,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;from&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String from;</span><br></pre></td></tr></table></figure><p>但是要注意的是，使用了配置中心功能后，如果占位符（${xxx}）没有被正确替换，整个程序是会报错了，不管你用了没用默认值，这个是不科学的。</p><h3 id="利用WebHook自动刷新"><a href="#利用WebHook自动刷新" class="headerlink" title="利用WebHook自动刷新"></a>利用WebHook自动刷新</h3><p>在引用了配置的类上添加<code>@RefreshScope</code>注解，即可实现自动刷新，还有一点，需要在git中的webhook（例如GitHub，GitLab，Gitee）添加上<a href="http://config-ip:port/bus/refresh即可。">http://config-ip:port/bus/refresh即可。</a></p><p>流程大致为： git仓库更新 -&gt; 触发webhook-&gt; 触发config的刷新端点-&gt; config通知应用 -&gt; 应用刷新配置内容。</p><h3 id="遇到的一个prefer-ip-address问题"><a href="#遇到的一个prefer-ip-address问题" class="headerlink" title="遇到的一个prefer-ip-address问题"></a>遇到的一个prefer-ip-address问题</h3><p>在调试过程中发现一个问题，如果在config服务端<code>prefer-ip-address</code>没有打开，客户端则会找不到config服务端。在网上找了一下关于该配置的解释，<br>希望对大家有用<a href="http://www.itmuch.com/spring-cloud-code-read/spring-cloud-code-read-eureka-registry-ip/">prefer-ip-address机制解释</a></p><p>config的大致内容就说完了，可能还差配置内容加密，稍微有些繁杂，有机会再补充，急需可以查一下<br><a href="https://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_security">官方文档</a>，或者别的中文博客</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;在服务中经常会遇到一些易变的参数，例如数据库地址、超时时间等等。这些参数与代码关系耦合度低，但是每改一次就去修改代码中的参数，再去编译部署&lt;</summary>
      
    
    
    
    
    <category term="spring cloud" scheme="https://jevonyang.github.io/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud实践分享-Eureka注册中心</title>
    <link href="https://jevonyang.github.io/2018/06/07/SpringCloud%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB-Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <id>https://jevonyang.github.io/2018/06/07/SpringCloud%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB-Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</id>
    <published>2018-06-07T03:21:58.000Z</published>
    <updated>2021-10-22T01:58:28.136Z</updated>
    
    <content type="html"><![CDATA[<p>随着业务需求增加，众多企业面临代码耦合严重、效率低下的问题。在Netflix开源了一套自己的微服务架构后，Spring随即也基于此推出SpringCloud。<br>目前来说，SpringCloud的门槛相对较低，在了解大致SpringCloud后即可上手，更多的是配置，或者是套路上的东西。当然我这么说只是对于希望快速上手的同学而言，源码博大精深，有兴趣可以多多研究。自己做微服务的也做了半年了，现在写一个demo，总结一下springcloud的基本用法，让我们的<br>微服务的小车先开起来。</p><p><a href="https://github.com/JevonYang/spring-cloud-microservice">spring-cloud-microservice代码</a></p><h2 id="项目构成"><a href="#项目构成" class="headerlink" title="项目构成"></a>项目构成</h2><p>项目采用module的形式，一个项目下分多个module，导入项目比较方便。</p><ul><li>[]Eureka注册中心</li><li>[]Config配置中心</li><li>[]Oauth2认证中心</li><li>[]Zuul网关</li><li>[]api-admin服务</li></ul><h2 id="注册中心Eureka"><a href="#注册中心Eureka" class="headerlink" title="注册中心Eureka"></a>注册中心Eureka</h2><p>Eureka作为服务的注册中心，服务间的互相调用都是通过Eureka来完成，所有的服务都将自己注册到eureka中。当A服务希望调用B服务时，A只需使用B的instanceId，而不是ip，即可完成调用。在分布式应用中，服务随机部署在各个服务器中，根据ip去调用服务极其低效，你再写代码。当服务启动多个实例时候，一般使用ribbon和feign，则会自动负载均衡，无需干预。</p><p>想启动一个Eureka服务注册中心，配置上也十分简单。首先在pom.xml中加入<code>spring-cloud-starter-eureka-server</code>依赖，再在入口类中加入<br>注解<code>@EnableEurekaServer</code>即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableEurekaServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class EurekaApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Eureka只希望standalone模式（只启动一个实例），事实上在配置文件application.yml无需配置内容，配置上基本信息以及端口即可。<br>如果希望启动HighAvailability模式(即启动多个实例),则可以参考一下配置。</p><p>在部署的时候，使用编译后同一个jar包，在启动后输入不同参数。例如使用命令<code>java -jar -Dspring.profiles.active=master your_jar_name.jar</code>，<br>则启动配置spring.profiles为配置master下的内容。而最上面一块的内容为公共配置，启动master配置时，实际的配置时公共配置+master配置；如果有些配置<br>两边都有，则master配置会覆盖公共配置内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#公共配置</span><br><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-server</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    lease-renewal-interval-in-seconds: 5</span><br><span class="line">    lease-expiration-duration-in-seconds: 5</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    fetch-registry: true</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># 配置master</span><br><span class="line">spring:</span><br><span class="line">  profiles: master</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: master</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://master:8080/eureka/,http://backup1:8080/eureka/,http://backup2:8080/eureka/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># 配置backup1</span><br><span class="line">spring:</span><br><span class="line">  profiles: backup1</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://master:8080/eureka/,http://backup1:8080/eureka/,http://backup2:8080/eureka/</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># 配置backup2</span><br><span class="line">spring:</span><br><span class="line">  profiles: backup2</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://master:8080/eureka/,http://backup1:8080/eureka/,http://backup2:8080/eureka/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面来说一个几个重点配置</p><p><code>eureka.client.registry-fetch-interval-seconds</code>表示服务间隔多久去Eureka中获取注册信息，默认为30s。</p><p><code>eureka.instance.lease-renewal-interval-in-seconds</code>表示服务给Eureka发送心跳间隔，默认为30s。如果该instance实现了HealthCheckCallback，并决定让自己unavailable的话，则该instance也不会接收到流量。</p><p><code>eureka.instance.lease-expiration-duration-in-seconds</code>表示Eureka上次收到服务的心跳后，等待下一次心跳的时间，如果超时则移除实例，默认为90s。</p><p><code>eureka.server.enable-self-preservation</code>表示是否开启自我保护模式，默认为true。默认情况下，如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例（默认90秒）。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。<br>Eureka通过“自我保护模式”来解决这个问题——当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。<br>综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留），也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。</p><p><code>eureka.server.eviction-interval-timer-in-ms</code>表示Eureka清理无效节点的时间间隔，默认为60,000ms。</p><p><code>eureka.client.register-with-eureka</code>表示是否将Eureka注册到自身，多实例中一边选择true。</p><p><code>eureka.client.fetch-registry</code>表示是否拉去注册的服务。假设，服务A只注册到master节点的Eureka，但是开启该选项，所有的Eureka节点都会注册该服务。</p><p><code>eureka.client.defaultZone</code>表示希望注册到Eureka的地址，格式为<code>http://ip:port/eureka/</code>,如果部署环境有dns，也可以将ip换成域名，如果有是ha模式，配置多个地址用逗号隔开。</p><p>以上为Eureka配置相对重要的配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随着业务需求增加，众多企业面临代码耦合严重、效率低下的问题。在Netflix开源了一套自己的微服务架构后，Spring随即也基于此推出SpringCloud。&lt;br&gt;目前来说，SpringCloud的门槛相对较低，在了解大致SpringCloud后即可上手，更多的是配置，或</summary>
      
    
    
    
    
    <category term="spring cloud" scheme="https://jevonyang.github.io/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>DevOps：GitLab+Jenkins+Docker实践分享</title>
    <link href="https://jevonyang.github.io/2017/08/08/DevOps%EF%BC%9AGitLab+Jenkins+Docker%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB/"/>
    <id>https://jevonyang.github.io/2017/08/08/DevOps%EF%BC%9AGitLab+Jenkins+Docker%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB/</id>
    <published>2017-08-08T07:37:58.000Z</published>
    <updated>2021-10-22T01:58:28.136Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>相信很多小团队仍然在使用SVN+手动发版的这样的方法，当代码量不断膨胀、开发人员不断上升，在管理上会愈发吃力。最近，领导说，小杨啊，我们要提升开发效率。于是，选择了Gitlab+Jenkins的主流工具，过程中遇到很多坑，希望和大家分享。</p></blockquote><p><img src="https://static.oschina.net/uploads/img/201709/26120628_Jt5S.jpg" alt="持续集成示意图" title="持续集成示意图"></p><h1 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h1><blockquote><p><a href="https://about.gitlab.com/">GitLab</a>简单的说就是自建版的Github，可以安装到自己的服务器上，主要功能代码管理、权限管理、代码可视化、需求管理。</p></blockquote><p>Server: Ubuntu 14.04</p><p>GitLab:10.0.1</p><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><ol><li><p>GitLab安装依赖包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install curl openssh-server ca-certificates postfix</span><br></pre></td></tr></table></figure></li><li><p>首先信任 GitLab 的 GPG 公钥:</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure><ol start="3"><li>修改或新建<code>/etc/apt/sources.list.d/gitlab-ce.list</code>加入清华的gitlab源，因为官方源实在是太慢了</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu trusty main</span><br></pre></td></tr></table></figure><ol start="4"><li>安装 gitlab-ce:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gitlab-ce</span><br></pre></td></tr></table></figure><ol start="5"><li>安装完成后，修改<code>/etc/gitlab/gitlab.rb</code>文件（有的文章说改别的地方，不推荐，Ubuntu 14.04改这里就行），将gitlab.example.com换为当前服务器的ip，例如192.168.1.1。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external_url &#x27;http://gitlab.example.com&#x27;</span><br></pre></td></tr></table></figure><ol start="6"><li>接着就重新配置gitlab，然后重启GitLab服务：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure#重新配置</span><br><span class="line">sudo gitlab-ctl restart#重新启动gitlab服务</span><br></pre></td></tr></table></figure><ul><li>服务重启完成后，在浏览器中输入服务器ip，不用加端口号，即可进入GitLab的界面，GitLab和Github功能大致一致。至于不会git操作的用户，请移步<a href="https://my.oschina.net/yangzijing/blog/1476531">Git简明教程</a></li></ul><h2 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h2><ul><li>在浏览器输入地址后，出现502：重新配置然后重启，一般来说gitlab启动需要一段时间，稍等即可。</li><li>在浏览器输入地址后，出现nginx、apache2或者别的：关闭相关服务，后重启gitlab。</li></ul><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Docker: 17.0</p><p>Docker的安装方法便不再赘述，官方教程很详细，简单明了。</p><p>Docker官方安装教程：<a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/">Ubuntu</a> <a href="https://docs.docker.com/engine/installation/linux/docker-ce/centos/">CentOS</a><br> <a href="https://docs.docker.com/compose/install/#install-compose">Docker-Compose</a></p><p>顺便再推荐<a href="https://docs.docker.com/get-started/">Docker官方教程</a>，以及<a href="https://hub.docker.com/">Docker官方镜像仓库</a>几乎所有工具的镜像在这里都可以找到。不出几年，我们将抛开所有繁杂的安装过程，拥抱docker镜像。</p><p>重点说一下的几个配置，在网上有很多教程、回答，在17版本中都已经失效。总体来说，目前版本（17.0.x）的docker的设置都配置化，不用再在docker的执行脚本中修改。</p><h2 id="访问远程Docker"><a href="#访问远程Docker" class="headerlink" title="访问远程Docker"></a>访问远程Docker</h2><p>被访问服务器中修改<code>/etc/default/docker</code>文件添加：0.0.0.0代表任何ip都可以访问，当然需要限制访问ip可以在这里设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=&quot;-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock&quot;</span><br></pre></td></tr></table></figure><h2 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h2><p>私有仓库是很有用的功能，简单几条命令即可创建私有仓库，同时，将自己的镜像上传到私有仓库，既保障的镜像安全，也为镜像备份。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br><span class="line">docker run -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure><p>私有仓库开启后，push或者pull的时候会报链接错误。此时需要修改<code>/etc/docker/daemon.json</code>文件即可，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;],</span><br><span class="line">  &quot;insecure-registries&quot;:[&quot;x.x.x.x:5000&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Stackoverflow上很多回答说修改<code>/etc/init.d/docker</code>或 <code>/etc/sysconfig/docker</code>抑或其他，在当前版本都是行不通。</p><h2 id="Docker代理"><a href="#Docker代理" class="headerlink" title="Docker代理"></a>Docker代理</h2><p>某些地方的服务器不能连外网，此时需要代理。创建<code>/etc/systemd/system/docker.service.d/http-proxy.conf</code>文件，添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot;</span><br></pre></td></tr></table></figure><p>若果需要https代理创建https-proxy.conf文件并做相应修改即可。接着重新载入Docker配置，重启服务，代理生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><p>Server: CentOS 7.2</p><p>Jenkins:2.7.9</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>首先添加yum源，然后使用yum安装，Jenkins本质上是一个war包，一定要注意在此之前需要安装Java。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/RedHat/jenkins.repo</span><br><span class="line">sudo rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key</span><br><span class="line">sudo yum install jenkins</span><br></pre></td></tr></table></figure></li><li>接下来配置<code>/etc/sysconfig/jenkins</code>文件，最重要的两条，一条是当前机器Java的路径；以及Jenkins的端口号，默认为8080，如果已被占用可以更换。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JENKINS_JAVA_CMD=&quot;/usr/local/java/jdk1.8/bin/java&quot;</span><br><span class="line">JENKINS_PORT=&quot;8080&quot;</span><br></pre></td></tr></table></figure>Jenkins服务重启<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service jenkins start/stop/restart</span><br><span class="line">sudo chkconfig jenkins on</span><br></pre></td></tr></table></figure></li><li>之后便可以在浏览器输入服务器ip:8080，看到Jenkins的页面。按照提示<code>/var/lib/jenkins/secrets/initalAdminPassword</code>文件中找到管理员密码，然后一路next即可，进入Jenkins界面。</li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>系统管理-&gt;Global Tool Configuration分别设置JDK、Git、Maven、Docker，其中name都是随便填的，路径填入相应软件的路径，值得注意的是有的只需要精确到所在文件，有的则需要精确到执行文件。当然，如果填的不对，会有黄字或红字提示。</p></li><li><p>系统管理-&gt;系统设置 中需要配置Maven项目配置和Docker Builder（需要装插件）。</p></li></ol><p>Maven中Local Maven Repository选择default即可，但是在Maven软件中，需要修改maven(你的maven路径)/conf/setting.xml中的修改<code>local repository</code>标签，例如以下地址。因为权限问题，如果把本地仓库放入root目录下，会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;localRepository&gt;/var/.m2/repository&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure><p>Docker Builder设置。首先安装Docker Builder插件，设置Docker URL为以下二选一。本地docker可以选择以下两种的任意一种。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unix:///var/run/docker.sock#连接本地docker</span><br><span class="line">tcp://xxx.x.xx.xx:2375#连接远程docker</span><br></pre></td></tr></table></figure><p>点Test Connection验证链接是否正确。连接远程出错请参看本文“访问远程Docker”这一小节，本地出现错误请修改Jenkins所在服务器中<code>/var/run/docker.sock</code>权限，最简单粗暴的是<code>chmod 777 /var/run/docker.sock</code>。</p><h2 id="控制Docker"><a href="#控制Docker" class="headerlink" title="控制Docker"></a>控制Docker</h2><p>控制Docker流程可以用脚本，也可以用Execute Docker Command插件，在设置好Docker Builder后，很容易设置Execute Docker Command，下面用脚本演示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -aq --filter=&#x27;name=yang&#x27; | paste -sd &quot;|&quot; -) #停止名为yang的容器</span><br><span class="line">docker rm $(docker ps -aq --filter=&#x27;name=yang&#x27; | paste -sd &quot;|&quot; -) #删除名为yang的容器</span><br><span class="line">docker build -t oppdocker:$BUILD_NUMBER .  #创建相应镜像，注意后面有个.</span><br><span class="line">docker create --name yang-p 4000:8080 yangdocker:$BUILD_NUMBER #创建容器</span><br><span class="line">docker tag yangdocker:$BUILD_NUMBER 10.0.210.148:5000/yangdocker:$BUILD_NUMBER #标记容器</span><br><span class="line">docker push 10.0.210.148:5000/yangdocker:$BUILD_NUMBER #标记容器到远程仓库</span><br><span class="line">docker start yang #启动容器</span><br></pre></td></tr></table></figure><h2 id="Pepeline"><a href="#Pepeline" class="headerlink" title="Pepeline"></a>Pepeline</h2><p>Pepeline事实上Groovy脚本，先放放，稍后写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;相信很多小团队仍然在使用SVN+手动发版的这样的方法，当代码量不断膨胀、开发人员不断上升，在管理上会愈发吃力。最近，领导说，小杨啊，我们要提升开发效率。于是，选择了Gitlab+Jenkins的主流工具，过程中遇到很多坑，希望和大家分享。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="devops" scheme="https://jevonyang.github.io/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Git简明教程</title>
    <link href="https://jevonyang.github.io/2017/07/20/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
    <id>https://jevonyang.github.io/2017/07/20/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</id>
    <published>2017-07-20T09:02:58.000Z</published>
    <updated>2021-10-22T01:58:28.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Git的安装"><a href="#一、Git的安装" class="headerlink" title="一、Git的安装"></a>一、Git的安装</h2><h3 id="1-Windows下安装"><a href="#1-Windows下安装" class="headerlink" title="1. Windows下安装"></a>1. Windows下安装</h3><p>请于<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> 下载exe文件，安装即可。完成后，在命令行下输入命令：</p><pre><code>git --version</code></pre><p>出现git版本号，即为安装成功。</p><p>若命令后出现错误，请检查环境变量，请加入git的环境变量，例如C:\Program Files\Git\cmd;。</p><h3 id="2-类Unix环境下安装"><a href="#2-类Unix环境下安装" class="headerlink" title="2. 类Unix环境下安装"></a>2. 类Unix环境下安装</h3><p>在Linux/类Unix环境下，利用仓库安装较为快捷，并且大多数Linux仓库中有git源。</p><p>例1、Debian/Ubuntu</p><pre><code>apt-get install git</code></pre><p>例2、Fedora</p><pre><code>yum install git</code></pre><p>更多请参见<a href="https://git-scm.com/download/linux">https://git-scm.com/download/linux</a></p><h2 id="二、Git的命令行操作"><a href="#二、Git的命令行操作" class="headerlink" title="二、Git的命令行操作"></a>二、Git的命令行操作</h2><h3 id="1-Git的本地配置"><a href="#1-Git的本地配置" class="headerlink" title="1.Git的本地配置"></a>1.Git的本地配置</h3><p>在安装后，还需配置用户的姓名及Email，配置命令如下：</p><pre><code>git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot;</code></pre><p>这样就可以让git服务器识别自己的身份。在第一次操作远程仓库的时候，会提示</p><pre><code>The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)?</code></pre><p>大意为，对方服务器是谁谁谁，是否连接。输入yes即可。</p><h3 id="2-SSH免密登录"><a href="#2-SSH免密登录" class="headerlink" title="2.SSH免密登录"></a>2.SSH免密登录</h3><ul><li><p>Windows在git bash中输入如下命令，然后一路回车。</p><pre><code>  ssh-keygen -t rsa -C &quot;email@example.com&quot;</code></pre></li><li><p>在C:\Users\xxx(你的用户名).ssh下产生两个文件：id_rsa和id_rsa.pub，其中pub文件即为你的公钥，讲公钥提交到服务器，即可免密登录。</p></li></ul><h3 id="3-克隆命令"><a href="#3-克隆命令" class="headerlink" title="3.克隆命令"></a>3.克隆命令</h3><p>从远程仓库克隆需要所需的源代码命令</p><pre><code>git clone git@[ip或者域名]:[远程仓库路径]例如：git clone git@10.192.10.40:/usr/repositories/opp.git</code></pre><h3 id="4-远程仓库配置"><a href="#4-远程仓库配置" class="headerlink" title="4.远程仓库配置"></a>4.远程仓库配置</h3><p>从远程仓库克隆下来源代码，我们不仅仅满足于此。与远程仓库相关的操作还很多，我们不能总是输入一大推链接，于是我们将仓库有个“别名”。</p><pre><code>git remote add origin git@10.192.10.40:/usr/repositories/opp.git</code></pre><p>其中origin即为所谓的别名，当我们需要更换远程仓库地址的时候，可以使用如下命令</p><pre><code>git remote set-url origin git@github.com:JevonYang/example.git</code></pre><h3 id="5-提交改动"><a href="#5-提交改动" class="headerlink" title="5.提交改动"></a>5.提交改动</h3><p>git作为分布式代码管理系统，代码的改变需要几个步骤，一般的来说，需要先改变本地的仓库的代码，再讲本地仓库的代码推送到远程仓库。</p><p>改变本地仓库代码，首先需要添加改动文件，再进行提交：</p><pre><code>git add filename 或者 git add . //添加改动文件git commit -m &quot;some comments&quot; //提交改动</code></pre><p>另外，我们可以通过一下命令查看，状态及相应记录</p><pre><code>git status//查看提交状态git log//查看提交记录</code></pre><p>前者增加一个文件的改动，后者增加全部文件改动，注意后面的英文符号点不要忘记。在git commit命令之后，会出现确认文件选项，即删除改动文件前#号保存即为提交完成。</p><h3 id="6-推送到远程仓库"><a href="#6-推送到远程仓库" class="headerlink" title="6.推送到远程仓库"></a>6.推送到远程仓库</h3><p>接下来，我们尝试将文件推送到远程仓库，使用如下命令：</p><pre><code>git push [远程仓库] [分支名称]例如：git push -u origin master</code></pre><p>如果刚刚没有改动文件的话，远程仓库是不会改变的。</p><h3 id="7-分支操作"><a href="#7-分支操作" class="headerlink" title="7.分支操作"></a>7.分支操作</h3><p>在很多时候，我们需要用到分支操作，在分支操作上进行一些改动。</p><pre><code>git checkout -b dev //建立并切换到分支上git push -u origin dev //将新建分支推送到远端git branch//查看分支</code></pre><h3 id="8-合并分支"><a href="#8-合并分支" class="headerlink" title="8.合并分支"></a>8.合并分支</h3><p>在开发某功能后，需要将以开发的内容合并到主干上。</p><pre><code>git checkout master //切换到主干git merge --no-ff dev //和Dev分支合并</code></pre><h3 id="9-解决冲突"><a href="#9-解决冲突" class="headerlink" title="9.解决冲突"></a>9.解决冲突</h3><p>有操作就有冲突，git也为我们提供了良好的解决冲突方法。我们假设目前有两个分支master和dev，在master中曾经有过修复bug的改动，而dev中有增加新的feature改动，目前希望将两个分支合并，这样显然会出现冲突。</p><pre><code>git merget --no-ff dev</code></pre><p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，当我们做出选择后，保存文件。</p><pre><code>git add .git commit -m &quot;some comments&quot;git push -u origin master</code></pre><p>在合并后，我们选择在此保存文件、提交文件，进而完成合并。</p><h3 id="10-暂存功能"><a href="#10-暂存功能" class="headerlink" title="10.暂存功能"></a>10.暂存功能</h3><p>在dev开发某功能时，急需改动主干分支上的bug，于是我们需要将dev开发的内容暂存起来。</p><pre><code>git stash//此时branch在dev上，把已开发内容进行暂存git checkout master//切换到主干分支，进行bug修复git checkout -b issuexx//创建分支，进行修复git checkout dev //切回开发分支git stash list //查看暂存功能列表git stash apply //从暂存区域恢复</code></pre><h3 id="11-标签操作"><a href="#11-标签操作" class="headerlink" title="11.标签操作"></a>11.标签操作</h3><p>增删标签</p><pre><code>git tag v1.0//为当前版本添加标签git tag -d v0.1 //删除标签</code></pre><p>增加过往标签</p><pre><code>git log --pretty=oneline --abbrev-commit//查看提交历史git tag v0.9 cc17032 //为commit id为cc17032的提交添加标签git tag -a v0.1 -m &quot;some comments&quot; cc17032 //添加标签、备注</code></pre><p>查看标签</p><pre><code>git tag//查看所有标签git show v1.0//查看标签信息</code></pre><p>推送标签到远端</p><pre><code>git push origin v1.0//推送某一标签git push origin --tags//推送全部标签</code></pre><h2 id="三、MyEclipse-egit插件使用"><a href="#三、MyEclipse-egit插件使用" class="headerlink" title="三、MyEclipse egit插件使用"></a>三、MyEclipse egit插件使用</h2><p>git插件仅仅是git功能的延伸，下文以MyEclipse为例说明。</p><h3 id="1-Git插件安装"><a href="#1-Git插件安装" class="headerlink" title="1.Git插件安装"></a>1.Git插件安装</h3><ul><li><p>下载MyEcilpse Git插件例如：<a href="http://download.csdn.net/detail/get_set/7688939">http://download.csdn.net/detail/get_set/7688939</a></p></li><li><p>在MyEcilpse安装目录dropins文件夹新建egit文件夹，<br>例如C:\Users\xxx(你的用户名)\AppData\Local\MyEclipse\MyEclipse 10\dropins\egit</p></li><li><p>放入解压后的文件，启动MyEclipse即可</p></li></ul><h3 id="2-从远端导入项目"><a href="#2-从远端导入项目" class="headerlink" title="2.从远端导入项目"></a>2.从远端导入项目</h3><ul><li>File-&gt;Import-&gt;Git-&gt;Projects from Git-&gt;URI-&gt;</li><li>输入远程仓库URI，例如<a href="mailto:&#x67;&#105;&#116;&#64;&#49;&#48;&#x2e;&#49;&#x39;&#50;&#x2e;&#49;&#48;&#x2e;&#x34;&#48;">&#x67;&#105;&#116;&#64;&#49;&#48;&#x2e;&#49;&#x39;&#50;&#x2e;&#49;&#48;&#x2e;&#x34;&#48;</a>:/usr/repositories/opp.git</li><li>IDE会自动填写host以及repository path</li><li>Connection中填写通讯协议ssh，端口22</li><li>Authentication中填写git服务器git账号及相应密码</li></ul><h2 id="四、Git服务器搭建"><a href="#四、Git服务器搭建" class="headerlink" title="四、Git服务器搭建"></a>四、Git服务器搭建</h2><h3 id="1-远端安装Git"><a href="#1-远端安装Git" class="headerlink" title="1.远端安装Git"></a>1.远端安装Git</h3><p>下文以CentOS举例说明</p><ul><li><p>远端利用yum源安装git，</p><pre><code>  yum -y install git</code></pre></li><li><p>远端添加账户:</p><pre><code>  groupadd git  useradd git -g git  passwd git  #参数是用户名</code></pre></li></ul><h3 id="2-远端建立仓库"><a href="#2-远端建立仓库" class="headerlink" title="2.远端建立仓库"></a>2.远端建立仓库</h3><ul><li><p>切换到git账户</p><pre><code>  su - git </code></pre></li><li><p>创建远程仓库，并会有相应提示，即为远程仓库的位置</p><pre><code>  mkdir test.git  cd test.git  git init --bare //创建裸仓  Initialized existing Git repository in /home/repositories/test.git/</code></pre></li></ul><h3 id="3-SSH免密码登录设置"><a href="#3-SSH免密码登录设置" class="headerlink" title="3.SSH免密码登录设置"></a>3.SSH免密码登录设置</h3><ul><li><p>配置ssh功能，以及密钥文件位置</p><p>  vim /etc/ssh/sshd_config</p></li><li><p>在该文件中，可以看到以下三项被#号注释，去掉#号，打开注释。</p><pre><code>      #RSAAuthentication yes      #PubkeyAuthentication yes      #AuthorizedKeysFile .ssh/authorized_keys</code></pre></li><li><p>在git目录下创建.ssh/authorized_keys文件用于放置密钥，可以用以下命令也可以手动粘贴</p><pre><code>  cat your_rsa_key.pub&gt;&gt;/home/git/.ssh/authorized_keys</code></pre></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>GIT官网<a href="https://git-scm.com/">1</a></p><p>Git教程-廖雪峰的官方网站<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">2</a></p><p>GIT教程-易百教程<a href="http://www.yiibai.com/git/">3</a></p><p>CentOS7下git服务器端搭建<a href="http://www.cnblogs.com/xuange306/articles/6800794.html">4</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Git的安装&quot;&gt;&lt;a href=&quot;#一、Git的安装&quot; class=&quot;headerlink&quot; title=&quot;一、Git的安装&quot;&gt;&lt;/a&gt;一、Git的安装&lt;/h2&gt;&lt;h3 id=&quot;1-Windows下安装&quot;&gt;&lt;a href=&quot;#1-Windows下安装&quot; cla</summary>
      
    
    
    
    
    <category term="git" scheme="https://jevonyang.github.io/tags/git/"/>
    
  </entry>
  
</feed>
